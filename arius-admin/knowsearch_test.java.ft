## Quick Settings - configure common code style and other settings here. -----------------------------------------------
## Set these to use special prefixes for test class members containing dependencies of certain types.
## Note that the template code below will ignore any prefix set to "" and use your IDE code style settings instead.
#set($dependencyMemberNamePrefix = "")
#set($mockDependencyMemberNamePrefix = "")
## Set this to use a special prefix for local fields containing arguments for test methods.
#set($parameterLocalFieldNamePrefix = "")
#set($mockParameterLocalFieldNamePrefix = "")
#set($removeName = "")
#set($sourceClass.testClassMemberName = "${sourceClass.testClassMemberName}")
#set($sourceClass.testClassLocalFieldName = "${sourceClass.testClassLocalFieldName}")
#set($shouldUseMockitoExtension = $ClassUtils.isInTestClasspath('org.mockito.junit.jupiter.MockitoExtension'))
#set($shouldUseMockitoBdd = false)
#set($shouldUseSpring = true)
## Configure how Bean DTOs are initialized.
#set($minNumberOfSettersToCall = 15)
#set($maxNumberOfSettersToCall = 70)
#set($useStaticImportForInitMocks = true)
## Set this to use mocks for mockable method parameters that end in "listener" or "callback" ignoring case.
#set($useMocksForListenerAndCallbackParameters = true)
#set($generateStubsAndVerifyStatements = true)
## Use this to specify custom initialization values for dependencies and method parameters of certain types;
## See https://squaretest.com#template_api_quick_settings for details.
#set($initExpressionOverrides = {} )
##----------------------------------------------------------------------------------------------------------------------

## Initialize the data model. This sets global variables based on the architype of the source class and Quick Settings.
## See the comments above the macro or https://squaretest.com#template_api_initializeTemplateDataModel for details.
#initializeTemplateDataModel()

## Package declaration
#if($StringUtils.isNotEmpty($sourceClass.packageName))
    #if($StringUtils.endsWithIgnoreCase($sourceClass.packageName, "impl"))
    #set($removeName =$StringUtils.removeEnd(${sourceClass.packageName}, '.impl') )
    #else
         #set($removeName =$sourceClass.packageName)
    #end
package $removeName;
#end

## Imports; Note that Squaretest invokes IntelliJ's import organize and code reformatter after creating the test class.
#foreach($importLine in $importLinesRequired)
    $importLine
#end
#if($shouldUseMockitoExtension)
import org.mockito.junit.jupiter.MockitoExtension;
#end
#if($useStaticImportForInitMocks)
import static org.mockito.MockitoAnnotations.$initMocksMethodName;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.spy;
#end
import java.util.concurrent.Callable;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.Future;
import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;
import static org.assertj.core.api.Assertions.within;
#renderImportsForMatchers()
#if($shouldUseSpring)
import org.mockito.junit.jupiter.MockitoSettings;
import org.mockito.quality.Strictness;
import org.mockito.junit.jupiter.MockitoExtension;
import org.junit.runner.RunWith;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.boot.test.context.SpringBootTest.WebEnvironment;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.junit.jupiter.SpringExtension;
import com.didichuxing.datachannel.arius.admin.core.component.SpringTool;
import org.springframework.test.context.junit4.SpringRunner;
#end
#if($shouldUseMockitoBdd)
import static org.mockito.BDDMockito.willAnswer;
import static org.mockito.BDDMockito.willReturn;
import static org.mockito.BDDMockito.willThrow;
import static org.mockito.BDDMockito.then;
import static org.mockito.BDDMockito.given;
#else
import static org.mockito.Mockito.doAnswer;
import static org.mockito.Mockito.doReturn;
import static org.mockito.Mockito.doThrow;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
#end
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.MockitoAnnotations;
import org.mockito.InjectMocks;
import org.mockito.stubbing.Answer;
#if($springController)
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.http.HttpStatus;
import org.springframework.http.HttpMethod;
import org.springframework.http.MediaType;
import org.springframework.mock.web.MockHttpServletResponse;
import org.springframework.test.context.junit.jupiter.SpringExtension;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.mock.web.MockMultipartFile;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestPostProcessors.user;
import static org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestPostProcessors.csrf;
#end

## Test class
#renderTestClassAnnotationsIfNeeded()
#if($StringUtils.endsWithIgnoreCase(${sourceClass.name}, "impl"))
#set($removeName =$StringUtils.removeEnd(${sourceClass.name}, 'Impl') )
class ${removeName}Test {
#else
class ${sourceClass.name}Test {
#end


#renderMockMvcDeclarationIfNeeded()

## Declare member fields for the dependencies.
#renderMemberDeclarations($mockMemberFields)
#renderMemberDeclarations($nonMockMemberFields)

## Declare a member field for the instance of the source class.
#if($sourceClassMemberNeeded)
    #if($shouldUseInjectMocks) @InjectMocks #end
    #if($StringUtils.endsWithIgnoreCase(${sourceClass.testClassMemberName}, "impl"))
        #set($sourceClass.testClassMemberName =$StringUtils.removeEnd(${sourceClass.testClassMemberName}, 'Impl') )
    #end
    private ${sourceClass.type.canonicalText} ${sourceClass.testClassMemberName};
#end

#if($mocksNeeded && !$shouldUseMockitoExtension && !$springController && $hasOpenMocksMethod)
    private AutoCloseable mockitoCloseable;
#end

## Render setUp() only if we need to instantiate source class.
#if($sourceClassMemberNeeded && !($shouldUseInjectMocks && $shouldUseMockitoExtension))
@BeforeEach
void setUp() throws Exception {
    #if($mocksNeeded && !$shouldUseMockitoExtension)
        #set($initMocksQualifier = "#if(!$useStaticImportForInitMocks)MockitoAnnotations.#else#end")
        #if($hasOpenMocksMethod)
            mockitoCloseable = ${initMocksQualifier}${initMocksMethodName}(this);
        #else
            ${initMocksQualifier}${initMocksMethodName}(this);
        #end
    #end
    ## Initialize the non-mock member fields.
    #foreach($field in $nonMockMemberFields)
        $field.testClassMemberName = $field.initExpression;
    #end
    ## Initialize the member containing the source class.
    #if($shouldUseInjectMocks) ## Do nothing.
    #elseif($sourceClass.preferredConstructor)
        ## Invoke the constructor.
        ${sourceClass.testClassMemberName} = new #methodCall($sourceClass.preferredConstructor, true) #if($sourceClass.abstract && !$sourceClass.sealed)$sourceClass.abstractClassBody#end;
        #if($shouldSetPackageLocalFields)
            #foreach($field in $dependencies)
                ${sourceClass.testClassMemberName}.${field.declaredName} = #if($field.shouldStoreInReference) $field.testClassMemberName #else $field.initExpression #end;
            #end
        #end
    #elseif($sourceClass.singleton)
        ${sourceClass.testClassMemberName} = $sourceClass.singletonAccessExpression;
    #else
        ## As a fallback, set the member to null and leave a comment.
        ${sourceClass.testClassMemberName} = null /* TODO: construct the instance */;
    #end
}
#if($mocksNeeded && !$shouldUseMockitoExtension && !$springController && $hasOpenMocksMethod)
@AfterEach
void tearDown() throws Exception {
    mockitoCloseable.close();
}
#end
#end
## Render the test methods.
#if($shouldCreateTestsForInstanceMethods)
    #renderTestMethods($sourceClass.instanceMethods.filterOut('private'))
#end
#renderTestMethods($sourceClass.staticMethods.filterOut('private'))
}

## Macros
## Add your own macros here. Newlines between macros will not appear in the generated test class;
## Squaretest automatically removes all but 1 newline at the end of the generated test class.

##----------------------------------------------------------------------------------------------------------------------
## renderTestClassAnnotationsIfNeeded()
## Renders the spring controller test class annotations if needed.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderTestClassAnnotationsIfNeeded)
    #if($springController)
        @ActiveProfiles("test")
        @ExtendWith({SpringExtension.class,MockitoExtension.class})
        @MockitoSettings(strictness = Strictness.LENIENT)
        @ContextConfiguration(classes ={ SpringTool.class })
        @WebMvcTest(${sourceClass.canonicalNameOrName}.class)
    #elseif($shouldUseSpring)
        @ActiveProfiles("test")
        @ExtendWith({SpringExtension.class,MockitoExtension.class})
        @MockitoSettings(strictness = Strictness.LENIENT)
        @RunWith(SpringRunner.class)
        @ContextConfiguration(classes ={ SpringTool.class })
        @SpringBootTest(webEnvironment = WebEnvironment.NONE)
    #elseif($mocksNeeded && $shouldUseMockitoExtension)
        @ExtendWith(MockitoExtension.class)
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## renderMockMvcDeclarationIfNeeded()
## Renders a MockMvc member field if one is needed.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderMockMvcDeclarationIfNeeded)
    #if($springController)
    @Autowired
    private MockMvc $mockMvcMemberName;
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## renderMemberDeclarations($fields)
## Renders test-class member declarations for the given List<Variable>.
## Param: $fields - the list of variables for which to render declarations.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderMemberDeclarations $fields)
    #set($macro.mockAnnotation = "#if($springController)@MockBean#else@Mock#end")
    #set($macro.nonMockAnnotation = "#if($springController)@Autowired#else#end")
    #foreach($field in $fields)
        #if($field.shouldBeMocked)
            $macro.mockAnnotation
        #else
            $macro.nonMockAnnotation
        #end
        private $field.type.canonicalText $field.testClassMemberName;
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## renderTestMethods($methods)
## Renders tests for the given List<Method>. This filters out getters/setters and other methods for which tests should
## not be rendered.
## Param: $methods - the list of methods for which to render tests.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderTestMethods $methods)
    #if($sourceClass.enum)
        #set($macro.methodsToUse = $methods)
    #else
        #set($macro.methodsToUse = $methods.filterOut('simpleGetterOrSetter').filterOut('abstract'))
    #end
    #foreach($method in $macro.methodsToUse)
        #if($method.shouldUseSimpleTest)
            #renderSimpleTestMethod($method)
        #else
            #renderTestMethodForPrimaryFlow($method)
            #renderTestMethodsForAltFlows($method)
        #end
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## renderTestMethodForPrimaryFlow($method)
## Renders primary flow test case for the given Method.
## Param: $method - the method for which to render the test.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderTestMethodForPrimaryFlow $method)
    #set($macro.mockedDIs = $modelAttributeProviderMethodDIs.concat($method.dependencyInteractions).satisfiedBy($dependencies.filter('shouldBeMocked')))
    #set($macro.testInfo = $TestInfo.primaryFlow($method, $macro.mockedDIs))
    #renderTestMethod($macro.testInfo)
#end

##----------------------------------------------------------------------------------------------------------------------
## renderTestMethodsForAltFlows($method)
## Renders test for alternate flows for the given method.
## Param: $method - the method for which to render alt-flow tests.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderTestMethodsForAltFlows $method)
    ## Render tests for exceptions declared by the source method.
    ## Determine if at at least one dependency interaction that we've mocked throws an exception.
    #set($macro.mockedDIs = $modelAttributeProviderMethodDIs.concat($method.dependencyInteractions).satisfiedBy($dependencies.filter('shouldBeMocked')))
    #set($macro.isControllerMethod = $springController && $controllerMethods.contains($method))
    #set($macro.shouldRenderTestsForIoParams = $method.static || (!$macro.isControllerMethod && !($sourceClass.enumValues.size() > 1)))
    #set($macro.runtimeOrNonJdkExRegex = '(java\.lang\.RuntimeException|^(?!java\.).+)')
    #set($macro.atLeastOneMockedDiThrows = $macro.mockedDIs.containsAnyWith('method.throwsException', true) || $macro.mockedDIs.containsAnyWithNonNull('method.returnType.brokenIoInitExpression') || $macro.mockedDIs.flatMap('method.javadocExceptions').containsAnyWithRegex('type.canonicalName', $macro.runtimeOrNonJdkExRegex))
    #set($macro.atLeastOneMockedDiReturnsFailure = $macro.mockedDIs.containsAnyWithNonNull('method.returnType.failureInitExpression'))
    #set($macro.atLeastOneParamHasIo = $method.parameters.containsAnyWithNonNull('type.brokenIoInitExpression'))
    ## Only render tests for the source method's declared exceptions if none of the source method's mocked DIs throw.
    ## If one of the mocked DIs throw, that test case will likely be the case where the source class throws the declared exception(s).
    #set($macro.shouldRenderTestsForDeclaredExceptions = !$macro.atLeastOneMockedDiThrows && !$macro.atLeastOneParamHasIo && !$macro.atLeastOneMockedDiReturnsFailure)
    #set($macro.allSourceMethodExceptions = $method.declaredExceptions.union($method.javadocExceptions, 'type.canonicalName'))
    #if(!$generateStubsAndVerifyStatements)
        #renderAltFlowTestsForDeclaredExceptions($method, $macro.allSourceMethodExceptions)
        #break
    #end
    ## Render alternate flow tests based on parameters.
    #if($macro.shouldRenderTestsForIoParams)
        #foreach($param in $method.parameters)
            #if($param.type.emptyIoInitExpression)
                #renderTestMethod($TestInfo.fromParamWithEmptyIo($method, $macro.mockedDIs, $param))
            #end
            #if($param.type.brokenIoInitExpression)
                #renderTestMethod($TestInfo.fromParamWithBrokenIo($method, $macro.mockedDIs, $param))
            #end
        #end
    #end
    ## Render alternate flow tests based on the dependency interactions.
    #foreach($di in $macro.mockedDIs)
        ## Determine info about the DI method return type.
        #set($macro.isListenableFuture = $ListenableFutureNames.contains($di.method.returnType.canonicalName))
        #set($macro.isStandardFuture = $StringUtils.equalsAny($di.method.returnType.canonicalName, 'java.util.concurrent.Future', 'java.util.concurrent.CompletableFuture', 'java.util.concurrent.CompletionStage'))
        #set($macro.isAnyFuture = $di.method.returnType.isAny('java.util.concurrent.Future'))
        #set($macro.firstTypeParamCanBeEmpty = $StringUtils.isNotEmpty($di.method.returnType.parameters.first.emptyInitExpression))
        #set($macro.firstTypeParamCanBeAbsent = $di.method.returnType.parameters.first.absentInitExpression && !$StringUtils.equals($di.method.returnType.parameters.first.absentInitExpression, 'null'))
        #set($macro.shouldRenderAbsentTest = !$di.field.type.isAny('java.util.concurrent.Executor') && !$di.returnValueIgnored &&
            ($di.method.returnTypeCanBeAbsent || ($macro.isListenableFuture && $macro.firstTypeParamCanBeAbsent)))
        #set($macro.shouldRenderEmptyTest = !$di.field.type.isAny('java.util.concurrent.Executor') && !$di.returnValueIgnored &&
            ($di.method.returnType.emptyInitExpression || ($macro.isListenableFuture && $macro.firstTypeParamCanBeEmpty)))
        #set($macro.shouldRenderEmptyIoTest = !$di.field.type.isAny('java.util.concurrent.Executor') &&
            ($di.method.returnType.emptyIoInitExpression || $di.method.returnType.dtoBeanWithInputIoProperty || ($macro.isListenableFuture && $di.method.returnType.parameters.first.emptyIoInitExpression)))
        #set($macro.shouldRenderBrokenIoTest = !$di.field.type.isAny('java.util.concurrent.Executor') &&
            ($di.method.returnType.brokenIoInitExpression || $di.method.returnType.dtoBeanWithInputIoProperty || ($macro.isListenableFuture && $di.method.returnType.parameters.first.brokenIoInitExpression)))
        #set($macro.shouldRenderFailureTest = !($di.field.type.isAny('java.util.concurrent.Executor') && $macro.isAnyFuture) && ($di.method.returnType.failureInitExpression || $macro.isStandardFuture || $macro.isListenableFuture))
        #if(!$di.method.declaredExceptions.empty)
            #set($macro.diExceptionsToUse = $di.method.declaredExceptions)
        #else
            #set($macro.diExceptionsToUse = $di.method.javadocExceptions.filterItemsWithRegex('type.canonicalName', $macro.runtimeOrNonJdkExRegex))
        #end
        #set($macro.diExceptionsToUse = $macro.diExceptionsToUse.union($di.method.undeclaredExceptions, 'type.canonicalName'))
        ## Render the alt flow tests.
        #if($macro.shouldRenderAbsentTest)
            ## Render the test case where this dependency interaction returns either null or an absent value.
            #renderTestMethod($TestInfo.fromDiToReturnAbsent($method, $macro.mockedDIs, $di))
        #end
        #if($macro.shouldRenderEmptyTest)
            ## Render the test case where this dependency interaction returns an empty value.
            #renderTestMethod($TestInfo.fromDiToReturnEmpty($method, $macro.mockedDIs, $di))
        #end
        #if($macro.shouldRenderEmptyIoTest)
            #renderTestMethod($TestInfo.fromDiToReturnEmptyIo($method, $macro.mockedDIs, $di))
        #end
        #if($macro.shouldRenderBrokenIoTest)
            #renderTestMethod($TestInfo.fromDiToReturnBrokenIo($method, $macro.mockedDIs, $di))
        #end
        #if($macro.shouldRenderFailureTest)
            #renderTestMethod($TestInfo.fromDiToReturnFailure($method, $macro.mockedDIs, $di))
        #end
        #foreach($exception in $macro.diExceptionsToUse)
            #renderTestMethod($TestInfo.fromDiThatThrows($method, $macro.mockedDIs, $di, $exception))
        #end
    #end
    #if($macro.shouldRenderTestsForDeclaredExceptions)
        #renderAltFlowTestsForDeclaredExceptions($method, $macro.allSourceMethodExceptions)
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## renderAltFlowTestsForDeclaredExceptions $method, $exceptions)
## Renders alt-flow tests where the provided $method is expected to throw the provided $exceptions.
## Param: $method - the method for which to render alt-flow tests.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderAltFlowTestsForDeclaredExceptions $method, $exceptions)
    #set($macro.mockedDIs = $modelAttributeProviderMethodDIs.concat($method.dependencyInteractions).satisfiedBy($dependencies.filter('shouldBeMocked')))
    #foreach($declaredException in $exceptions)
        #renderTestMethod($TestInfo.fromExpectedException($method, $macro.mockedDIs, $declaredException))
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## renderTestMethod($testInfo)
## Renders the test for the given Method.
## Param: $testInfo - information about which case this test should cover.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderTestMethod $testInfo)
#set($_ = $CodeStyleUtils.beginMethodScope())
#if($sourceClass.enum)
    #renderTestMethodForEnum($testInfo)
#elseif($sourceClass.packageVisibleStaticCreatorMethods.contains($testInfo.method) && !$sourceClass.singleton && !$testInfo.expectedException && !$testInfo.paramWithEmptyIo && !$testInfo.paramWithBrokenIo)
    #renderStaticCreatorMethodPrimaryFlowTest($testInfo)
#elseif($springController && $controllerMethods.contains($testInfo.method))
    #renderTestMethodForController($testInfo)
#elseif($springController && !$method.static) ## Do nothing. This could be a method with @ExceptionHandler, @InitBinder, etc. Those should be covered in the other test cases.
#else
    ## Determine if we should create an assertEquals(...) call.
    #set($macro.returnTypeIsArrayWithComparableType = $testInfo.method.returnType.array && ($testInfo.method.returnType.deepArrayComponentType.primitive || $testInfo.method.returnType.deepArrayComponentType.overridesEquals))
    #set($macro.shouldCreateAssertEqualsCall =
        $testInfo.method.returnType && ($testInfo.method.returnType.primitive || $testInfo.method.returnType.overridesEquals || $testInfo.method.returnType.array || $testInfo.expectedValueNull)
        && ($testInfo.method.returnType.classT || $testInfo.method.returnType.allNestedTypeParamsOverrideEquals || $testInfo.expectedValueEmpty || $testInfo.expectedValueAbsent || $macro.returnTypeIsArrayWithComparableType)
        && !$testInfo.expectedException)
    #set($macro.shouldStoreExpectedValue = $macro.shouldCreateAssertEqualsCall && !$testInfo.method.returnType.simple && !$testInfo.expectedValueEmpty && !$testInfo.expectedValueAbsent)
    ## Determine the test case suffix to use for this test method and store the result in: $testCaseSuffix.
    #determineTestCaseSuffix($testInfo)

    @Test
    void ${method.name}${testInfo.method.overloadSuffix}${testCaseSuffix}Test()
            throws Exception {
    // Setup
    ## Declare parameters to use to invoke the method.
    #foreach($param in $testInfo.method.parameters.filter('shouldStoreInReference', true))
        #if($param == $testInfo.paramWithEmptyIo)
            #declareAndInitLocalVarImpl($param, $param.type.emptyIoInitExpression, true)
        #elseif($param == $testInfo.paramWithBrokenIo)
            #declareAndInitLocalVarImpl($param, $param.type.brokenIoInitExpression, true)
        #else
            #declareAndInitLocalVar($param, true)
        #end
    #end
    #if($macro.shouldStoreExpectedValue)
        #declareAndInitLocalVar($testInfo.method.returnType, true)
    #end
    #renderStubs($testInfo)

    // Run the test
    #set($macro.qualifier = "#if($testInfo.method.static)${sourceClass.canonicalNameOrName}#else${sourceClass.testClassMemberName}#end")
    #if($testInfo.expectedException)
        assertThatThrownBy(() -> ${macro.qualifier}.#methodCall($testInfo.method, false)).isInstanceOf(${testInfo.expectedException.type.canonicalNameOrName}.class);
    #else
        #if($testInfo.method.returnType) final $testInfo.method.returnType.canonicalText result = #end ${macro.qualifier}.#methodCall($testInfo.method, false);

        // Verify the results
        #if($macro.shouldCreateAssertEqualsCall)
            #if($testInfo.expectedValueNull)
                assertThat(result).isNull();
            #elseif($testInfo.expectedValueTrue)
                assertThat(result).isTrue();
            #elseif($testInfo.expectedValueAbsent && $StringUtils.equalsAny($testInfo.method.returnType.canonicalName, 'java.util.Optional', 'java.util.OptionalLong', 'java.util.OptionalInt', 'java.util.OptionalDouble'))
                assertThat(result).isEmpty();
            #else
                #set($macro.expectedValueExpression = "#if($macro.shouldStoreExpectedValue)$testInfo.method.returnType.testClassLocalFieldName #elseif($testInfo.expectedValueEmpty)$testInfo.method.returnType.emptyInitExpression #elseif($testInfo.expectedValueAbsent)$testInfo.method.returnType.absentInitExpression #else $testInfo.method.returnType.initExpression #end")
                #assertEqualsCall($macro.expectedValueExpression, 'result', $testInfo.method.returnType);
            #end
        #end
    #end
    #renderVerifyStatements($testInfo)
    }
#end
#set($_ = $CodeStyleUtils.endMethodScope())
#end

##----------------------------------------------------------------------------------------------------------------------
## renderTestMethodForController $testInfo)
## Renders the test for the given controller Method.
## Param: $testInfo - information about which alternate flow this test should cover.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderTestMethodForController $testInfo)
    ## Determine the test case suffix to use for this test method and store the result in: $testCaseSuffix.
    #determineTestCaseSuffix($testInfo)
    ## Determine the path from the controller annotations.
    #set($macro.pathHolder = $MutableString.create())
    #determinePath($testInfo.method, $macro.pathHolder)
    ## Determine the path args from the method parameters.
    #set($macro.pathArgsHolder = $MutableString.create())
    #determinePathArgs($testInfo.method, $macro.pathArgsHolder)
    ## Determine if this method is a multiplart upload (has one or more files).
    #set($macro.multipartUploadHolder = $MutableBoolean.create(false))
    #determineIfMultipartUpload($testInfo.method, $macro.multipartUploadHolder)
    ## Determine the request method to use for this test.
    #set($macro.requestMethodHolder = $MutableString.create())
    #determineRequestMethod($testInfo.method, $macro.multipartUploadHolder.value, $macro.requestMethodHolder)
    ## Determine the response content type to use in the mock reqeust.
    #set($macro.responseContentTypeHolder = $MutableString.create())
    #determineResponseContentType($testInfo.method, $macro.responseContentTypeHolder)
    ## Determine the expected response code to use for the test.
    #set($macro.expectedResponseCodeHolder = $MutableString.create())
    #determineExpectedResponseCode($testInfo.expectedException, $macro.expectedResponseCodeHolder)
    ## Determine the HTTP content; i.e. params(..), file(..), content(..), etc calls for this test.
    #set($macro.httpParamsCallStringHolder = $MutableString.create())
    #determineHttpParamsCallString($testInfo.method, $macro.requestMethodHolder.value, $macro.multipartUploadHolder.value, $macro.httpParamsCallStringHolder)
    #if($macro.requestMethodHolder.value == 'trace')
        #set($macro.requestMethodCall = 'request(HttpMethod.TRACE, ' + '"' + $macro.pathHolder.value + '"' + $macro.pathArgsHolder.value + ')')
    #else
        #set($macro.requestMethodCall = $macro.requestMethodHolder.value + '(' + '"' + $macro.pathHolder.value + '"' + $macro.pathArgsHolder.value + ')')
    #end
    #if($testInfo.expectedValueEmpty)
        #set($macro.expectedResponse = '"[]"')
    #elseif($testInfo.expectedValueAbsent)
        #set($macro.expectedResponse = '""')
    #else
        #set($macro.expectedResponse = '"expectedResponse"')
    #end
    @Test
    void ${method.name}${testInfo.method.overloadSuffix}${testCaseSuffix}Test()
            throws Exception {
        // Setup
        #renderStubs($testInfo)

        // Run the test
        final MockHttpServletResponse response = ${mockMvcMemberName}.perform(${macro.requestMethodCall}${Newline}${macro.httpParamsCallStringHolder}.accept($macro.responseContentTypeHolder))${Newline}.andReturn().getResponse();

        // Verify the results
        #assertEqualsCall($macro.expectedResponseCodeHolder.value, 'response.getStatus()', false);
        #assertEqualsCall($macro.expectedResponse, 'response.getContentAsString()', false);
        #renderVerifyStatements($testInfo)
    }
#end

##----------------------------------------------------------------------------------------------------------------------
## determineExpectedResponseCode($expectedException, $expectedResponseCodeHolder)
## Determines the expected response code based on the provided exception and writes the string to
## $expectedResponseCodeHolder.value.
## Param: $expectedException     - the expected exception for the test case.
## Param: $expectedResponseCodeHolder - the MutableString that will contain the expected response code.
##----------------------------------------------------------------------------------------------------------------------
#macro(determineExpectedResponseCode $expectedException, $expectedResponseCodeHolder)
    #if($expectedException)
        #set($expectedResponseCodeHolder.value = 'HttpStatus.INTERNAL_SERVER_ERROR.value()')
    #else
        #set($expectedResponseCodeHolder.value = 'HttpStatus.OK.value()')
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## determineResponseContentType($method, $responseContentTypeHolder)
## Determines the content type to use for the response and stores the result in $responseContentTypeHolder.value.
## Param: $method     - the expected exception for the test case.
## Param: $responseContentTypeHolder - the MutableString that will contain the expected response code.
##----------------------------------------------------------------------------------------------------------------------
#macro(determineResponseContentType $method, $responseContentTypeHolder)
    #set($macro.superMethods = $FluentList.of($method).concat($method.superMethods))
    #if($restController || $macro.superMethods.containsAnyWithAnnotation('ResponseBody', 'JsonView')
        || $method.returnType.isAny('org.springframework.http.HttpEntity') || $method.returnType.parameters.first.isAny('org.springframework.http.HttpEntity'))
        #set($responseContentTypeHolder.value = 'MediaType.APPLICATION_JSON')
    #else
        #set($responseContentTypeHolder.value = 'MediaType.TEXT_HTML')
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## determineIfMultipartUpload($method, $multipartUploadHolder)
## Determines if the controller method is handling a multipart upload request and saves the output (boolean) to
## $multipartUploadHolder.value.
## Param: $method     - the method.
## Param: $multipartUploadHolder - the MutableBoolean that will contain the output value.
##----------------------------------------------------------------------------------------------------------------------
#macro(determineIfMultipartUpload $method, $multipartUploadHolder)
#set($multipartUploadHolder.value = false)
#set($macro.superMethods = $FluentList.of($method).concat($method.superMethods))
#set($macro.superParams = $method.parameters.concat($method.superMethods.flatMap('parameters')))
## Check the controller method(s) mapping annotations to see if one of them has consumes=multipart.
#if($macro.superMethods.flatMap('annotations').filterItemsWithAny('name', $ControllerMethodAnnotations).flatMap('parameters').filter('key', 'consumes').containsAnyWithRegex('value.text', '^.*(MULTIPART_|multipart/).*$'))
    #set($multipartUploadHolder.value = true)
    #break($macro)
#end
#if($macro.superParams.containsAnyWithAnnotation('RequestPart'))
    #set($multipartUploadHolder.value = true)
    #break($macro)
#end
#foreach($param in $method.parameters)
    #if($param.type.isOrHasAnyNestedTypeParamWith($MultipartInterfaceTypes))
        #set($multipartUploadHolder.value = true)
        #break($macro)
    #end
    #determineIfClassHasMultipartFile($param, $multipartUploadHolder)
    #if($multipartUploadHolder.value)
        #break($macro)
    #end
#end
#end

##----------------------------------------------------------------------------------------------------------------------
## determineIfClassHasMultipartFile($method, $paramClassHasMultipartHolder)
## Determines if the parameter or the parameter's inner most type parameter have a member field containing a multipart
## file type. This macro writes the output boolean to $paramClassHasMultipartHolder.value.
## Param: $param - the parameter
## Param: $paramClassHasMultipartHolder - the MutableBoolean that will contain the output.
##----------------------------------------------------------------------------------------------------------------------
#macro(determineIfClassHasMultipartFile $param, $paramClassHasMultipartHolder)
    #set($paramClassHasMultipartHolder.value = false)
    #set($macro.typeToUse = $param.type)
    #set($macro.hasMultipleTypeParams = false)
    #foreach($i in [1..25])
        #if($macro.typeToUse.parameters.empty)
            #break($foreach)
        #elseif($macro.typeToUse.parameters.size() > 1)
            #set($macro.hasMultipleTypeParams = true)
            #break($foreach)
        #else
            #set($macro.typeToUse = $macro.typeToUse.parameters.first)
        #end
    #end
    #if($macro.hasMultipleTypeParams)
        #break($macro)
    #end
    #set($macro.paramClass = $ClassUtils.resolveClass($macro.typeToUse))
    #if($macro.paramClass)
        #foreach($field in $macro.paramClass.fields)
            #if($field.type.isOrHasAnyNestedTypeParamWith($MultipartInterfaceTypes))
                #set($paramClassHasMultipartHolder.value = true)
                #break($macro)
            #end
        #end
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## determinePath($method, $pathHolder)
## Determines the path to use for the controller method and writes it to $pathHolder.value.
## Param: $method     - the method to determine the controller path for.
## Param: $pathHolder - the MutableString the controller path will be written to.
##----------------------------------------------------------------------------------------------------------------------
#macro(determinePath $method, $pathHolder)
    #set($pathHolder.value = 'path')
    #set($macro.superMethods = $FluentList.of($method).concat($method.superMethods))
    #set($macro.annotationPath = $macro.superMethods.flatMap('annotations').filterItemsWithAny('name', $RequestMappingAnnotations).flatMap('parameters').filter('key', 'path', 'value').filterOut('value.text', '{}').first.value.text)
    ## Replace environment variable placeholders like ${companyName} with the String: /companyName/.
    #set($macro.tempPath = $StringUtils.replaceAll($macro.annotationPath, '\$\{(.*?)\}', '/$1/'))
    ## The path can be a String[] with multiple Strings. Take the longest substring between two double quote chars.
    #set($macro.tempPath = $StringUtils.longest($StringUtils.substringsBetween($macro.tempPath, '"')))
    #if($macro.tempPath)
        #set($pathHolder.value = $basePath + '/' + $macro.tempPath)
    #elseif($macro.annotationPath)
        ## The path could be a reference to a constant; e.g. MyPaths.FooPath.
        #set($pathHolder.value = $basePath + '/' + 'path')
    #else
        ## There is no mapping annotation with a path parameter. Use the base path.
        #set($pathHolder.value = $basePath)
    #end
    ## Remove duplicate forward slashes.
    #set($pathHolder.value = $pathHolder.value.replaceAll('/+', '/').trim())
#end

##----------------------------------------------------------------------------------------------------------------------
## determinePathArgs($method, $pathArgsHolder)
## Determines the path variables to use for the controller method and writes it to determinePathArgs.value.
## Param: $method         - the method to determine the controller path args for.
## Param: $pathArgsHolder - the MutableString the controller path args String will be written to.
##----------------------------------------------------------------------------------------------------------------------
#macro(determinePathArgs $method, $pathArgsHolder)
    #set($pathArgsHolder.value = '')
    #foreach($param in $method.parameters)
        #set($macro.superParamsAtIndex = $FluentList.of($param).concat($method.getSuperMethodParametersAtIndex($foreach.index)))
        #if($macro.superParamsAtIndex.containsAnyWithAnnotation('PathVariable', 'MatrixVariable'))
            ## Determine the parameter value.
            #set($macro.isUUID = $StringUtils.equals($param.type.canonicalName, 'java.util.UUID'))
            #set($macro.paramValue = '"' + $param.declaredName + '"')
            #if($param.type.isOrHasAnyNestedTypeParamWith($BooleanTypes))
                #set($macro.paramValue = 'false')
            #elseif($param.type.isOrHasAnyNestedTypeParamWith($NumericTypes))
                #set($macro.paramValue = '0')
            #elseif($StringUtils.equalsAny($param.type.canonicalName, 'java.lang.String', 'java.lang.CharSequence'))
                #set($macro.paramValue = $param.type.initExpression)
            #elseif($macro.isUUID)
                #set($macro.paramValue = '"' + $StringUtils.substringBetween($param.type.initExpression, '"') + '"')
            #end
            #set($pathArgsHolder.value = $pathArgsHolder.value + ', ' + $macro.paramValue)
        #end
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## determineHttpParamsCallString($method, $requestMethod, $multipartUpload, $httpParamsCallStringHolder)
## Determines the string of method calls needed to add parts to the HTTP request that the controller method is expecting.
## The result is stored as a String in $httpParamsCallStringHolder.value.
## Param: $method - the controller method to create the http method calls for.
## Param: $requestMethod - the request method determined for this method; e.g. 'get', 'post', 'multipart', etc.
## Param: $multipartUpload - boolean indicating whether or not this is a multipart request.
## Param: $httpParamsCallStringHolder - MutableString object whose value will contain the output of this macro.
##----------------------------------------------------------------------------------------------------------------------
#macro(determineHttpParamsCallString $method, $requestMethod, $multipartUpload, $httpParamsCallStringHolder)
    #set($httpParamsCallStringHolder.value = '')
    #set($macro.fileParamsCallStringHolder = $MutableString.create(''))
    #set($macro.superParams = $method.parameters.concat($method.superMethods.flatMap('parameters')))
    #set($macro.superMethods = $FluentList.of($method).concat($method.superMethods))
    #set($macro.needsUser = $hasClassSecurityAnnotations || $macro.superMethods.containsAnyWithAnnotation($SecurityAnnotations))
    #set($macro.methodReturnsData = $restController || $macro.superMethods.containsAnyWithAnnotation('ResponseBody') || $method.returnType.isAny('org.springframework.http.HttpEntity') || $method.returnType.parameters.first.isAny('org.springframework.http.HttpEntity'))
    #set($macro.needsCsrf = $StringUtils.equalsAny($requestMethod, 'post', 'put', 'patch', 'multipart', 'delete') && !$macro.methodReturnsData)
    #foreach($param in $method.parameters)
        #set($macro.superParamsAtIndex = $FluentList.of($param).concat($method.getSuperMethodParametersAtIndex($foreach.index)))
        ## Determine the parameter name.
        #set($macro.paramNameFromAnnotation = $macro.superParamsAtIndex.flatMap('annotations').filterItemsWithAny('name', $ControllerParameterAnnotations).flatMap('parameters').filter('key', 'name', 'value').map('value.text').filterOutItem('').first)
        #set($macro.paramNameFromAnnotation = $StringUtils.unwrap($macro.paramNameFromAnnotation, '"'))
        #set($macro.paramName = "#if($macro.paramNameFromAnnotation && !$macro.paramNameFromAnnotation.contains('${'))${macro.paramNameFromAnnotation}#else${param.declaredName}#end")
        ## Determine the parameter value.
        #set($macro.paramValue = '"' + $macro.paramName + '"')
        #set($macro.isUUID = $StringUtils.equals($param.type.canonicalName, 'java.util.UUID'))
        #if($param.type.isOrHasAnyNestedTypeParamWith($BooleanTypes))
            #set($macro.paramValue = '"false"')
        #elseif($param.type.isOrHasAnyNestedTypeParamWith($NumericTypes))
            #set($macro.paramValue = '"0"')
        #elseif($StringUtils.equalsAny($param.type.canonicalName, 'java.lang.String', 'java.lang.CharSequence'))
            #set($macro.paramValue = $param.type.initExpression)
        #elseif($macro.isUUID)
            #set($macro.paramValue = '"' + $StringUtils.substringBetween($param.type.initExpression, '"') + '"')
        #end
        #set($macro.paramClassHasMultipartHolder = $MutableBoolean.create(false))
        #determineIfClassHasMultipartFile($param, $macro.paramClassHasMultipartHolder)
        #if($param.type.isAny('java.util.Locale') || $param.type.parameters.first.isAny('java.util.Locale'))
            #if($macro.superParamsAtIndex.containsAnyWithAnnotation('RequestParam'))
                #set($httpParamsCallStringHolder.value = $httpParamsCallStringHolder.value + '.param(' + '"' + $macro.paramName + '"' + ', ' + $macro.paramValue + ')' + $Newline)
            #else
                #set($httpParamsCallStringHolder.value = $httpParamsCallStringHolder.value + '.locale(java.util.Locale.US)' + $Newline)
            #end
        #elseif($macro.superParamsAtIndex.containsAnyWithAnnotation('AuthenticationPrincipal', 'CurrentSecurityContext') || $param.type.isAny('java.security.Principal') || $param.type.parameters.first.isAny('java.security.Principal'))
            #set($macro.needsUser = true)
        #elseif($macro.superParamsAtIndex.containsAnyWithAnnotation('RequestHeader'))
            #set($httpParamsCallStringHolder.value = $httpParamsCallStringHolder.value + '.header(' + '"' + $macro.paramName + '"' + ', ' + $macro.paramValue + ')' + $Newline)
        #elseif($macro.superParamsAtIndex.containsAnyWithAnnotation('CookieValue'))
            #set($httpParamsCallStringHolder.value = $httpParamsCallStringHolder.value + '.cookie(new javax.servlet.http.Cookie(' + '"' + $macro.paramName + '"' + ', ' + $macro.paramValue + '))' + $Newline)
        #elseif($macro.superParamsAtIndex.containsAnyWithAnnotation('SessionAttribute'))
            #set($httpParamsCallStringHolder.value = $httpParamsCallStringHolder.value + '.sessionAttr(' + '"' + $macro.paramName + '"' + ', ' + $param.type.initExpression + ')' + $Newline)
        #elseif($macro.superParamsAtIndex.containsAnyWithAnnotation('RequestAttribute'))
            #set($httpParamsCallStringHolder.value = $httpParamsCallStringHolder.value + '.requestAttr(' + '"' + $macro.paramName + '"' + ', ' + $param.type.initExpression + ')' + $Newline)
        #elseif($macro.superParamsAtIndex.containsAnyWithAnnotation('RequestBody') || $param.type.isAny('org.springframework.http.HttpEntity') || $param.type.parameters.first.isAny('org.springframework.http.HttpEntity'))
            #if($restController || $macro.methodReturnsData || $param.type.springSimple || $param.type.parameters.first.springSimple || $param.type.parameters.first.parameters.first.springSimple)
                ## If this is a rest controller, set the content to a placeholder string. The user will likely replace the string with something like Files.readAllBytes('testcase1.json').
                #set($httpParamsCallStringHolder.value = $httpParamsCallStringHolder.value + '.content(' + '"content"' + ')' + '.contentType(' + 'MediaType.APPLICATION_JSON' + ')' + $Newline)
            #else
                #renderParamsForEachField($param, $macro.paramName, $macro.paramValue, $macro.fileParamsCallStringHolder, $httpParamsCallStringHolder)
            #end
        #elseif($macro.superParamsAtIndex.containsAnyWithAnnotation('RequestPart') || $param.type.isOrHasAnyNestedTypeParamWith($MultipartInterfaceTypes))
            #set($macro.fileParamsCallStringHolder.value = $macro.fileParamsCallStringHolder.value + '.file(new MockMultipartFile(' + '"' + $macro.paramName + '"' + ', "originalFilename", MediaType.APPLICATION_JSON_VALUE, "content".getBytes()))' + $Newline)
        #elseif($macro.paramClassHasMultipartHolder.value)
            ## This is a form pojo, HttpEntity<pojo>, Mono<HttpEntity<pojo>>, etc with a field containing either Multipart for List<Multipart>.
            #renderParamsForEachField($param, $macro.paramName, $macro.paramValue, $macro.fileParamsCallStringHolder, $httpParamsCallStringHolder)
        #elseif($macro.superParamsAtIndex.containsAnyWithAnnotation('PathVariable', 'MatrixVariable')) ## Do nothing.
        #elseif($param.type.isAny('org.springframework.security.web.csrf.CsrfToken', 'org.springframework.security.web.server.csrf.CsrfToken') || $param.type.parameters.first.isAny('org.springframework.security.web.csrf.CsrfToken', 'org.springframework.security.web.server.csrf.CsrfToken'))
            #set($macro.needsCsrf = true)
        #elseif($macro.superParamsAtIndex.containsAnyWithAnnotation('RequestParam'))
            #set($httpParamsCallStringHolder.value = $httpParamsCallStringHolder.value + '.param(' + '"' + $macro.paramName + '"' + ', ' + $macro.paramValue + ')' + $Newline)
        #elseif($macro.superParamsAtIndex.containsAnyWithAnnotation('Valid', 'Validated'))
            #if(!$macro.superParams.containsAnyWithAnnotation('RequestBody'))
                ## This is likely the request body.
                #if($macro.methodReturnsData)
                    #set($httpParamsCallStringHolder.value = $httpParamsCallStringHolder.value + '.content(' + '"content"' + ')' + '.contentType(' + 'MediaType.APPLICATION_JSON' + ')' + $Newline)
                #else
                    #renderParamsForEachField($param, $macro.paramName, $macro.paramValue, $macro.fileParamsCallStringHolder, $httpParamsCallStringHolder)
                #end
            #end
        #elseif($macro.superParamsAtIndex.containsAnyWithAnnotation('ModelAttribute'))
            ## If there is a @RequestBody parameter, the content is provided there and this @ModelAttribute likely comes from another source (session or @ModelAttribute method).
            ## The same is true if this is a multipart upload or the source class has an @ModelAttribute provider method that returns the same type as the parameter.
            ## The same is true if this is a request type that should not have a body (GET, HEAD, DELETE,... etc).
            ## In all cases, do nothing.
            #if($macro.superParams.containsAnyWithAnnotation('RequestBody')
                || $multipartUpload
                || $allModelAttributeProviderMethods.containsAnyWith('returnType.canonicalName', $param.type.canonicalName)
                || $StringUtils.equalsAny($requestMethod, 'get', 'head', 'delete', 'options', 'trace')) ## Do nothing.
            #else
                #set($httpParamsCallStringHolder.value = $httpParamsCallStringHolder.value + '.param(' + '"' + $macro.paramName + '"' + ', ' + $macro.paramValue + ')' + $Newline)
            #end
        #elseif($allModelAttributeProviderMethods.containsAnyWith('returnType.canonicalName', $param.type.canonicalName)) ## Ignore params provided by model attribute provider methods.
        #elseif($param.type.isAny($IgnoredControllerTypes) || $param.type.parameters.first.isAny($IgnoredControllerTypes)
            || $StringUtils.startsWithAny($param.type.canonicalName, 'org.springframework', 'javax')
            || $StringUtils.startsWithAny($param.type.parameters.first.canonicalName, 'org.springframework', 'javax'))
            ## Ignore params that are surfacing parts of the HTTP stack that we don't care about.
        #elseif($param.type.springSimple || ($param.type.isAny('java.util.Optional') && $param.type.parameters.first.springSimple) || ($param.type.parameters.first.isAny('java.util.Optional') && $param.type.parameters.first.parameters.first.springSimple))
            ## If the param is a SimpleType, Optional<SimpleType> or Mono<Optional<SimpleType>>, use .param(..).
            #set($httpParamsCallStringHolder.value = $httpParamsCallStringHolder.value + '.param(' + '"' + $macro.paramName + '"' + ', ' + $macro.paramValue + ')' + $Newline)
        #elseif($macro.superParams.containsAnyWithAnnotation('RequestBody')) ## There is a RequestBody parameter, and this is not it. Assume this non-simple type is provided by a model attribute provider method.
        #elseif($StringUtils.equalsAny($requestMethod, 'post', 'put', 'patch', 'multipart'))
            ## If this is a post/put/patch request, assume the type is a data transfer object.
            #if(!$macro.superParams.containsAnyWithAnnotation('RequestBody'))
                ## This is likely the request body.
                #if($macro.methodReturnsData)
                    #set($httpParamsCallStringHolder.value = $httpParamsCallStringHolder.value + '.content(' + '"content"' + ')' + '.contentType(' + 'MediaType.APPLICATION_JSON' + ')' + $Newline)
                #else
                    #renderParamsForEachField($param, $macro.paramName, $macro.paramValue, $macro.fileParamsCallStringHolder, $httpParamsCallStringHolder)
                #end
            #end
        #end
    #end
    #if($macro.needsUser)
        #set($httpParamsCallStringHolder.value = $httpParamsCallStringHolder.value + '.with(user("username"))' + $Newline)
    #end
    #if($macro.needsCsrf)
        #set($httpParamsCallStringHolder.value = $httpParamsCallStringHolder.value + '.with(csrf())' + $Newline)
    #end
    ## Prepend the .file(..) calls. They need to come first, because .file(..) returns an instance of MockMultipartHttpServletRequestBuilder
    ## while the other calls: with(..), param(..), etc return instances of MockHttpServletRequestBuilder. MockHttpServletRequestBuilder
    ## does not have a .file(..) method.
    #set($httpParamsCallStringHolder.value = $macro.fileParamsCallStringHolder.value + $httpParamsCallStringHolder.value)
#end

##----------------------------------------------------------------------------------------------------------------------
## renderParamsForEachField($param, $paramName, $paramValue, $fileParamsCallStringHolder, $httpParamsCallStringHolder)
## Determines the .param(..) and .file(..) calls needed for each field in this parameter's class.
## If the param class has multiple type parameters or one of the type params is a $MultipartInterfaceTypes, this
## macro renders a single call of: .param(..) or .file(..).
## If the param has nested type parameters; e.g. Mono<HttpEntity<FormData>>, this macro will use the fields of the inner
## most type (FormData) to generate .param(..) and .file(..) calls.
## The calls are stored in MutableString objects: $fileParamsCallStringHolder, $httpParamsCallStringHolder.
## Param: $param      - parameter to create .param(..) and .file(..) calls for.
## Param: $paramName  - the name of the param, determined by annotations and/or the declared name.
## Param: $paramValue - the value to use for the parameter in the cases where it is either a simple type or has
##                      multiple type parameters.
## Param: $fileParamsCallStringHolder - MutableString to which .file(..) calls will be written.
## Param: $httpParamsCallStringHolder - MutableString to which .param(..) calls will be written.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderParamsForEachField $param, $paramName, $paramValue, $fileParamsCallStringHolder, $httpParamsCallStringHolder)
    ## Find the actual type to use. The parameter type could be something like: Flux<HttpEntity<FormData>>.
    ## In this case we want to use the FormData type.
    #set($macro.hasMultipleTypeParams = false)
    #set($macro.hasFileParam = $param.type.isOrHasAnyNestedTypeParamWith($MultipartInterfaceTypes))
    #set($macro.typeToUse = $param.type)
    ## Velocity doesn't have while loops, so iterate from 1-25 instead; there shouldn't be more than 25 levels of nested type params.
    #foreach($i in [1..25])
        #if($macro.typeToUse.parameters.empty)
            #break($foreach)
        #elseif($macro.typeToUse.parameters.size() > 1)
            #set($macro.hasMultipleTypeParams = true)
            #break($foreach)
        #else
            #set($macro.typeToUse = $macro.typeToUse.parameters.first)
        #end
    #end
    #if($macro.hasMultipleTypeParams || $macro.typeToUse.springSimple || !$macro.typeToUse.canonicalName)
        ## The type has multiple params. It is likely a Map<String, String> or MultiValueMap<String, String> containing
        ## all of the params. See https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/bind/annotation/RequestParam.html.
        #if($macro.hasFileParam)
            #set($fileParamsCallStringHolder.value = $fileParamsCallStringHolder.value + '.file(new MockMultipartFile("partName", "originalFilename", MediaType.APPLICATION_JSON_VALUE, "content".getBytes()))' + $Newline)
        #else
            #set($httpParamsCallStringHolder.value = $httpParamsCallStringHolder.value + '.param(' + '"' + $paramName + '"' + ', ' + $paramValue + ')' + $Newline)
        #end
    #else
        #set($macro.canonicalNamesInCallStack = {})
        #set($macro.canonicalNamesInCallStack[$macro.typeToUse.canonicalName] = true)
        #set($macro.numberOfSettersCalled = $MutableInt.create(0))
        #set($macro.maxRecursiveBeanInitDepth = 10)
        #initFormFieldsRecursively($macro.typeToUse, '', $macro.maxRecursiveBeanInitDepth, $macro.canonicalNamesInCallStack, $macro.numberOfSettersCalled, $fileParamsCallStringHolder, $httpParamsCallStringHolder)
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## initFormFieldsRecursively($typeOrVariable, $formFieldPrefix, $recursiveCounter, $canonicalNamesInCallStack, $numberOfSettersCalled, $fileParamsCallStringHolder, $httpParamsCallStringHolder)
## This should only be called from the #renderParamsForEachField() macro.
## Determines the .param(..) and .file(..) calls needed for each field in this parameter's class recursively.
## Param: $typeOrVariable            - the Type or Variable for which to render the bean setup code.
## Param: $formFieldPrefix           - the prefix to use for .param(..) or .file(..) calls generated for fields in this class.
## Param: $recursiveCounter          - the countdown counter indicating the number of recursive calls remaining.
## Param: $canonicalNamesInCallStack - the canonical names of beans in the recursive init call stack. This is used to
##        avoid infinite recursive init loops, in addition to the countdown counter.
## Param: $numberOfSettersCalled     - MutableInt containing the total number of setters called in this recurisve call.
## Param: $fileParamsCallStringHolder - MutableString to which .file(..) calls will be written.
## Param: $httpParamsCallStringHolder - MutableString to which .param(..) calls will be written.
##----------------------------------------------------------------------------------------------------------------------
#macro(initFormFieldsRecursively $typeOrVariable, $formFieldPrefix, $recursiveCounter, $canonicalNamesInCallStack, $numberOfSettersCalled, $fileParamsCallStringHolder, $httpParamsCallStringHolder)
    #if(!$typeOrVariable.type.parameters.empty)#break #end
    #set($macro.beanClass = $ClassUtils.resolveClass($typeOrVariable))
    #if(!$macro.beanClass)#break #end
    #foreach($field in $macro.beanClass.instanceFields.filterOut('transient'))
        #if($numberOfSettersCalled.intValue() >= $maxNumberOfSettersToCall)#break #end
        #set($_ = $numberOfSettersCalled.increment())
        #set($macro.newRecursiveCounter = $recursiveCounter - 1)
        ## Determine the parameter value.
        #set($macro.paramName = $formFieldPrefix + $field.declaredNameWithoutPrefix)
        #set($macro.paramValue = '"' + $field.declaredNameWithoutPrefix + '"')
        #set($macro.isUUID = $StringUtils.equals($field.type.canonicalName, 'java.util.UUID'))
        #if($field.type.isOrHasAnyNestedTypeParamWith($BooleanTypes))
            #set($macro.paramValue = '"false"')
        #elseif($field.type.isOrHasAnyNestedTypeParamWith($NumericTypes))
            #set($macro.paramValue = '"0"')
        #elseif($StringUtils.equalsAny($field.type.canonicalName, 'java.lang.String', 'java.lang.CharSequence'))
            #set($macro.paramValue = $field.type.initExpression)
        #elseif($macro.isUUID)
            #set($macro.paramValue = '"' + $StringUtils.substringBetween($field.type.initExpression, '"') + '"')
        #end
        #if($field.type.isAny('java.lang.Iterable') || $field.type.array)
            ## Get the inner type.
            #if($field.type.isAny('java.lang.Iterable')) #set($macro.innerType = $field.type.parameters.first)
            #elseif($field.type.array) #set($macro.innerType = $field.type.deepArrayComponentType) #end
            ## Initialize the fields recursively.
            #if($macro.innerType.isAny($MultipartInterfaceTypes))
                #set($fileParamsCallStringHolder.value = $fileParamsCallStringHolder.value + '.file(new MockMultipartFile("'+ $macro.paramName + '", "originalFilename", MediaType.APPLICATION_JSON_VALUE, "content".getBytes()))' + $Newline)
            #elseif($macro.innerType.springSimple)
                #set($httpParamsCallStringHolder.value = $httpParamsCallStringHolder.value + '.param(' + '"'+ $macro.paramName + '"' + ', ' + '"value1"' + ', ' + '"value2"' + ')' + $Newline)
            #elseif($macro.innerType.canonicalName && !$canonicalNamesInCallStack[$macro.innerType.canonicalName] && $macro.innerType.parameters.empty && $recursiveCounter > 0)
                #set($macro.newFormFieldPrefix = $macro.paramName + '0.')
                #set($canonicalNamesInCallStack[$macro.innerType.canonicalName] = true)
                #initFormFieldsRecursively($macro.innerType, $macro.newFormFieldPrefix, $macro.newRecursiveCounter, $canonicalNamesInCallStack, $numberOfSettersCalled, $fileParamsCallStringHolder, $httpParamsCallStringHolder)
                #set($canonicalNamesInCallStack[$macro.innerType.canonicalName] = false)
            #else
                #set($httpParamsCallStringHolder.value = $httpParamsCallStringHolder.value + '.param(' + '"'+ $macro.paramName + '"' + ', ' + '"value1"' + ', ' + '"value2"' + ')' + $Newline)
            #end
        #elseif(!$field.type.parameters.empty)
            ## This is a Map or some other type with a generic. How this is bound to an HTTP parameter depends on the
            ## User's Thymeleaf template and installed type converters. Just render a parameter.
            #set($httpParamsCallStringHolder.value = $httpParamsCallStringHolder.value + '.param(' + '"'+ $macro.paramName + '"' + ', ' + $macro.paramValue + ')' + $Newline)
        #elseif($field.type.isAny($MultipartInterfaceTypes))
            #set($fileParamsCallStringHolder.value = $fileParamsCallStringHolder.value + '.file(new MockMultipartFile("'+ $macro.paramName + '", "originalFilename", MediaType.APPLICATION_JSON_VALUE, "content".getBytes()))' + $Newline)
        #elseif($field.type.springSimple || $macro.isUUID || $StringUtils.startsWith($field.type.canonicalName, 'java.'))
            #set($httpParamsCallStringHolder.value = $httpParamsCallStringHolder.value + '.param(' + '"'+ $macro.paramName + '"' + ', ' + $macro.paramValue + ')' + $Newline)
        #else
            ## The field is a DTO. How it is bound to HTTP parameters depends on the developer's Thymeleaf template and
            ## installed type converters. Render the type's fields recursively using the field's declared name as the prefix.
            #if($field.type.canonicalName && !$canonicalNamesInCallStack[$field.type.canonicalName] && $recursiveCounter > 0)
                #set($macro.newFormFieldPrefix = $macro.paramName + '_')
                #set($canonicalNamesInCallStack[$field.type.canonicalName] = true)
                #initFormFieldsRecursively($field.type, $macro.newFormFieldPrefix, $macro.newRecursiveCounter, $canonicalNamesInCallStack, $numberOfSettersCalled, $fileParamsCallStringHolder, $httpParamsCallStringHolder)
                #set($canonicalNamesInCallStack[$field.type.canonicalName] = false)
            #else
                #set($httpParamsCallStringHolder.value = $httpParamsCallStringHolder.value + '.param(' + '"'+ $macro.paramName + '"' + ', ' + $macro.paramValue + ')' + $Newline)
            #end
        #end
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## determineRequestMethod($method)
## Determines the name of the request method in MockMvcRequestBuilders to use to test the given controller method
## and stores the result in $requestMethodHolder.
## Param: $method - the controller method for which the test is being generated.
## Param: $type - the Type of the arguments; this is used to determine which assertEquals method to call.
## Out:   $requestMethodHolder the name of the request method in MockMvcRequestBuilders to use to test the controller.
##----------------------------------------------------------------------------------------------------------------------
#macro(determineRequestMethod $method, $multipartUpload, $requestMethodHolder)
    #set($macro.superMethods = $FluentList.of($method).concat($method.superMethods))
    #if($multipartUpload)
        #set($requestMethodHolder.value = 'multipart')
    #elseif($macro.superMethods.containsAnyWithAnnotation('GetMapping'))
        #set($requestMethodHolder.value = 'get')
    #elseif($macro.superMethods.containsAnyWithAnnotation('PostMapping', 'NotificationMessageMapping'))
        #set($requestMethodHolder.value = 'post')
    #elseif($macro.superMethods.containsAnyWithAnnotation('PutMapping'))
        #set($requestMethodHolder.value = 'put')
    #elseif($macro.superMethods.containsAnyWithAnnotation('DeleteMapping'))
        #set($requestMethodHolder.value = 'delete')
    #elseif($macro.superMethods.containsAnyWithAnnotation('PatchMapping'))
        #set($requestMethodHolder.value = 'patch')
    #elseif($macro.superMethods.containsAnyWithAnnotation('RequestMapping'))
        ## The mapping is defined using the old format: @RequestMapping(method=RequestMethod.POST)
        #set($macro.methodKeyParams = $macro.superMethods.flatMap('annotations').filter('name', 'RequestMapping').flatMap('parameters').filter('key', 'method'))
        #if($macro.methodKeyParams.containsAnyWithRegex('value.text', '^.*(RequestMethod.GET|GET).*$'))
            #set($requestMethodHolder.value = 'get')
        #elseif($macro.methodKeyParams.containsAnyWithRegex('value.text', '^.*(RequestMethod.POST|POST).*$'))
            #set($requestMethodHolder.value = 'post')
        #elseif($macro.methodKeyParams.containsAnyWithRegex('value.text', '^.*(RequestMethod.PUT|PUT).*$'))
            #set($requestMethodHolder.value = 'put')
        #elseif($macro.methodKeyParams.containsAnyWithRegex('value.text', '^.*(RequestMethod.DELETE|DELETE).*$'))
            #set($requestMethodHolder.value = 'delete')
        #elseif($macro.methodKeyParams.containsAnyWithRegex('value.text', '^.*(RequestMethod.PATCH|PATCH).*$'))
            #set($requestMethodHolder.value = 'patch')
        #elseif($macro.methodKeyParams.containsAnyWithRegex('value.text', '^.*(RequestMethod.OPTIONS|OPTIONS).*$'))
            #set($requestMethodHolder.value = 'options')
        #elseif($macro.methodKeyParams.containsAnyWithRegex('value.text', '^.*(RequestMethod.HEAD|HEAD).*$'))
            #set($requestMethodHolder.value = 'head')
        #elseif($macro.methodKeyParams.containsAnyWithRegex('value.text', '^.*(RequestMethod.TRACE|TRACE).*$'))
            #set($requestMethodHolder.value = 'trace')
        #else
            #set($requestMethodHolder.value = 'get')
        #end
    #else
        #set($requestMethodHolder.value = 'get')
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## renderStaticCreatorMethodPrimaryFlowTest($testInfo)
## Renders the primary flow test case for the given static method that returns an instance of the SourceClass.
## This test case calls methods on the returned source class to ensure it was created properly by the static method.
## Param: $testInfo - information about which case this test should cover.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderStaticCreatorMethodPrimaryFlowTest $testInfo)
    #set($macro.shouldRenderSetup = $testInfo.method.parameters.containsAnyWith('shouldStoreInReference', true))
    @Test
    void ${method.name}${testInfo.method.overloadSuffix}Test() throws Exception {
    #if($macro.shouldRenderSetup)
        // Setup
        ## Declare parameters to use to invoke the method.
        #foreach($param in $testInfo.method.parameters.filter('shouldStoreInReference', true))
            #declareAndInitLocalVar($param, true)
        #end

    #end
    // Run the test
    final $testInfo.method.returnType.canonicalText $testInfo.method.returnType.testClassLocalFieldName = ${sourceClass.canonicalNameOrName}.#methodCall($testInfo.method, false);
    #set($macro.instanceMethodsToCall = $sourceClass.allNonObjectLowestOverrideMethods.filterOut('static').filter('accessLevel', 'public', 'packagePrivate').filterOut('returnType', $Null).filterOut('simpleSetter').filterOutItemsWithRegex('name', '^(set|with|update)[A-Z0-9_]+.*'))
    #foreach($instanceMethod in $macro.instanceMethodsToCall)
        #foreach($param in $instanceMethod.parameters.filter('shouldStoreInReference', true))
            #declareAndInitLocalVar($param, true)
        #end
        ## There is a bug in the Velocity engine where macro calls in set statements don't work correctly when the
        ## VM_PERM_INLINE_LOCAL setting is enabled. To work around this, define a VTL block containing the macro call, then
        ## evaluate the block and assign the result in a set statement.
        #define($__workaroundCallExpression) ${testInfo.method.returnType.testClassLocalFieldName}.#methodCall($instanceMethod, false) #end
        #set($macro.callExpression = "$__workaroundCallExpression")
        #assertEqualsCall($instanceMethod.returnType.initExpression, $macro.callExpression, $instanceMethod.returnType);
    #end
    }
#end

##----------------------------------------------------------------------------------------------------------------------
## assertEqualsCall($expected, $actual, $type)
## Renders the assertEquals method call appropriate for the given parameters.
## Param: $expected - the value to use for the expected argument of the assertEquals method call.
## Param: $actual - the value to use for the actual argument of the assertEquals method call.
## Param: $type - the Type of the arguments; this is used to determine which assertEquals method to call.
##----------------------------------------------------------------------------------------------------------------------
#macro(assertEqualsCall $expected, $actual, $type)
    #if($StringUtils.equalsAny($type.canonicalName, 'double', 'java.lang.Double')) assertThat($actual).isEqualTo($expected, within(0.0001)) #break
    #elseif($StringUtils.equalsAny($type.canonicalName, 'float', 'java.lang.Float')) assertThat($actual).isEqualTo($expected, within(0.0001f)) #break
    #elseif($StringUtils.equalsAny($type.canonicalName, 'boolean', 'java.lang.Boolean')) assertThat($actual).isFalse() #break
    #else assertThat($actual).isEqualTo($expected) #end
#end

##----------------------------------------------------------------------------------------------------------------------
## renderStubs($testInfo)
## Renders the stubs (when, doAnswer, doThrow, etc) for the given test case.
## Param: $testInfo - information about which case this test should cover.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderStubs $testInfo)
    #if(!$generateStubsAndVerifyStatements)#break #end
    #foreach($di in $testInfo.mockedDIs)
        #if($testInfo.shouldReturnAbsent($di))
            #renderAbsentStub($di)
        #elseif($testInfo.shouldReturnEmpty($di))
            #renderEmptyStub($di)
        #elseif($testInfo.shouldReturnEmptyIo($di))
            #renderEmptyIoStub($di)
        #elseif($testInfo.shouldReturnBrokenIo($di))
            #renderBrokenIoStub($di)
        #elseif($testInfo.shouldThrowException($di))
            #renderExceptionStub($di, $testInfo.getExceptionToThrow($di))
        #elseif($testInfo.shouldReturnFailure($di))
            #renderFailureStub($di)
        #else
            #renderPrimaryFlowStub($di)
        #end
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## renderPrimaryFlowStubs($dis)
## Renders the primary flow stubs (when, doAnswer, etc) for the given dependency interactions.
## Param: $dis - the dependency interactions to render stubs for.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderPrimaryFlowStubs $dis)
    #foreach($di in $dis)
        #renderPrimaryFlowStub($di)
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## renderPrimaryFlowStubs($di)
## Renders the primary flow stub (when, doAnswer, etc) for the given dependency interaction.
## Param: $di - the dependency interaction to render stubs for.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderPrimaryFlowStub $di)
    #set($macro.sourceVar = $di.field.possibleSourceVariables.intersection($dependencies).first)
    #set($macro.qualifier = "#if($shouldSetPackageLocalFields)${sourceClass.testClassMemberName}.${macro.sourceVar.declaredName}#else $macro.sourceVar.testClassMemberName #end")
    #if($di.method.parameters.containsAnyWith('type.canonicalName', 'java.lang.Runnable'))
        #renderAnswerForRunnable($di)
    #elseif($di.method.parameters.containsAnyWith('type.canonicalName', 'java.util.concurrent.Callable'))
        #renderAnswerForCallable($di)
    #elseif($di.method.returnType)
        #set($macro.hasInnerWildcardType = $di.method.returnType.parameters.containsAnyWith('wildcard', true))
        ## Declare a local variable for the return type if needed.
        #if($di.method.returnType.shouldStoreInReference)

            // Configure ${di.field.type.name}.${di.method.name}(...).
            #declareAndInitLocalVar($di.method.returnType, false)
        #end
        #set($macro.returnTypeExpression = "#if($di.method.returnType.shouldStoreInReference)$di.method.returnType.testClassLocalFieldName#else $di.method.returnType.initExpression #end")
        #if($macro.hasInnerWildcardType)
            $doReturn($macro.returnTypeExpression).$when($macro.qualifier).#methodCall($di.method, false);
        #else
            $when($macro.qualifier.#methodCall($di.method, false)).$thenReturn($macro.returnTypeExpression);
        #end
        #if($di.method.returnType.shouldStoreInReference) $Newline #end
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## renderAnswerForRunnable($di)
## Renders the doAnswer(...) statement for the dependency interaction whose method takes in at least one Runnable.
## Param: $di - the dependency interaction to render the doAnswer(...) statement for.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderAnswerForRunnable $di)
    #set($macro.sourceVar = $di.field.possibleSourceVariables.intersection($dependencies).first)
    #set($macro.qualifier = "#if($shouldSetPackageLocalFields)${sourceClass.testClassMemberName}.${macro.sourceVar.declaredName}#else $macro.sourceVar.testClassMemberName #end")
    #set($macro.indexOfRunnable = $di.method.parameters.indexOfAny('type.canonicalName', 'java.lang.Runnable'))
    $doAnswer(invocation -> {
        ((Runnable) invocation.getArguments()[$macro.indexOfRunnable]).run();
        #if($StringUtils.equalsAny($di.method.returnType.canonicalName, 'java.util.concurrent.Future', 'java.util.concurrent.CompletableFuture'))
            return CompletableFuture.completedFuture(null);
        #elseif($di.method.returnType.canonicalName == 'com.google.common.util.concurrent.ListenableFuture')
            final com.google.common.util.concurrent.SettableFuture settableFuture = com.google.common.util.concurrent.SettableFuture.create();
            settableFuture.set(null);
            return settableFuture;
        #elseif($di.method.returnType.canonicalName == 'java.util.concurrent.ScheduledFuture')
            final java.util.concurrent.ScheduledFuture<?> mockFuture = #mock('java.util.concurrent.ScheduledFuture.class');
            $doReturn(null).$when(mockFuture).get();
            $doReturn(true).$when(mockFuture).isDone();
            return mockFuture;
        #elseif($di.method.returnType)
            return $di.method.returnType.initExpression;
        #else
            return null;
        #end
    }).$when($macro.qualifier).#methodCall($di.method, false);
#end

##----------------------------------------------------------------------------------------------------------------------
## renderAnswerForCallable($di)
## Renders the doAnswer(...) statement for the dependency interaction whose method takes in at least one Callable.
## Param: $di - the dependency interaction to render the doAnswer(...) statement for.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderAnswerForCallable $di)
    #set($macro.sourceVar = $di.field.possibleSourceVariables.intersection($dependencies).first)
    #set($macro.qualifier = "#if($shouldSetPackageLocalFields)${sourceClass.testClassMemberName}.${macro.sourceVar.declaredName}#else $macro.sourceVar.testClassMemberName #end")
    #set($macro.indexOfCallable = $di.method.parameters.indexOfAny('type.canonicalName', 'java.util.concurrent.Callable'))
    $doAnswer(invocation -> {
        final Callable<?> callable = (Callable<?>) invocation.getArguments()[$macro.indexOfCallable];
        #if($StringUtils.equalsAny($di.method.returnType.canonicalName, 'java.util.concurrent.Future', 'java.util.concurrent.CompletableFuture'))
            return CompletableFuture.completedFuture(callable.call());
        #elseif($di.method.returnType.canonicalName == 'com.google.common.util.concurrent.ListenableFuture')
            final com.google.common.util.concurrent.SettableFuture settableFuture = com.google.common.util.concurrent.SettableFuture.create();
            settableFuture.set(callable.call());
            return settableFuture;
        #elseif($di.method.returnType.canonicalName == 'java.util.concurrent.ScheduledFuture')
            final java.util.concurrent.ScheduledFuture<?> mockFuture = #mock('java.util.concurrent.ScheduledFuture.class');
            $doReturn(callable.call()).$when(mockFuture).get();
            $doReturn(true).$when(mockFuture).isDone();
            return mockFuture;
        #elseif($di.method.returnType)
            return $di.method.returnType.initExpression;
        #else
            return null;
        #end
    }).$when($macro.qualifier).#methodCall($di.method, false);
#end

##----------------------------------------------------------------------------------------------------------------------
## renderExceptionStub($di, $exceptionToThrow)
## Configures the provided dependency interaction ($di) to throw the provided $exceptionToThrow.
## Param: $di - the dependency interaction to be configured to throw.
## Param: $exceptionToThrow - the exception the $di should throw.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderExceptionStub $di, $exceptionToThrow)
    #set($macro.sourceVar = $di.field.possibleSourceVariables.intersection($dependencies).first)
    #set($macro.qualifier = "#if($shouldSetPackageLocalFields)${sourceClass.testClassMemberName}.${macro.sourceVar.declaredName}#else $macro.sourceVar.testClassMemberName #end")
    #if($di.method.returnType)
        $when($macro.qualifier.#methodCall($di.method, false)).$thenThrow(${exceptionToThrow.type.canonicalNameOrName}.class);
    #else
        $doThrow(${exceptionToThrow.type.canonicalNameOrName}.class).$when($macro.qualifier).#methodCall($di.method, false);
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## renderAbsentStub($di)
## Configures the provided dependency interaction ($di) to return either null or an absent value.
## Param: $di - the dependency interaction to be configured to return an absent value.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderAbsentStub $di)
    #set($macro.sourceVar = $di.field.possibleSourceVariables.intersection($dependencies).first)
    #set($macro.qualifier = "#if($shouldSetPackageLocalFields)${sourceClass.testClassMemberName}.${macro.sourceVar.declaredName}#else $macro.sourceVar.testClassMemberName #end")
    #set($macro.hasInnerWildcardType = $di.method.returnType.parameters.containsAnyWith('wildcard', true))
    #set($macro.isListenableFuture = $ListenableFutureNames.contains($di.method.returnType.canonicalName))
    #set($macro.shouldStoreInReference = !$di.method.inferredNullable && ($macro.isListenableFuture || $di.method.returnType.shouldBeSpied))
    #if($macro.shouldStoreInReference)

        // Configure ${di.field.type.name}.${di.method.name}(...).
        #if($macro.isListenableFuture)
            #declareAndInitListenableFuture($di.method.returnType, $di.method.returnType.parameters.first.absentInitExpression)
        #elseif($di.method.returnType.shouldBeSpied)
            #declareAndInitLocalVarImpl($di.method.returnType, $di.method.returnType.absentInitExpression, false)
        #end
    #end
    #set($macro.returnTypeExpression = "#if($macro.shouldStoreInReference)$di.method.returnType.testClassLocalFieldName#else $di.method.returnType.absentInitExpression #end")
    #if($macro.hasInnerWildcardType)
        $doReturn($macro.returnTypeExpression).$when($macro.qualifier).#methodCall($di.method, false);
    #else
        $when($macro.qualifier.#methodCall($di.method, false)).$thenReturn($macro.returnTypeExpression);
    #end
    #if($macro.shouldStoreInReference) $Newline #end
#end

##----------------------------------------------------------------------------------------------------------------------
## renderEmptyIoStub($di)
## Configures the provided dependency interaction ($di) to return either null or an absent value.
## Param: $di - the dependency interaction to be configured to return an absent value.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderEmptyIoStub $di)
    #set($macro.sourceVar = $di.field.possibleSourceVariables.intersection($dependencies).first)
    #set($macro.qualifier = "#if($shouldSetPackageLocalFields)${sourceClass.testClassMemberName}.${macro.sourceVar.declaredName}#else $macro.sourceVar.testClassMemberName #end")
    #set($macro.hasInnerWildcardType = $di.method.returnType.parameters.containsAnyWith('wildcard', true))
    #set($macro.isListenableFuture = $ListenableFutureNames.contains($di.method.returnType.canonicalName))
    #set($macro.shouldStoreInReference = true)
    #if($macro.shouldStoreInReference)

        // Configure ${di.field.type.name}.${di.method.name}(...).
        #if($macro.isListenableFuture)
            #declareAndInitListenableFuture($di.method.returnType, $di.method.returnType.parameters.first.emptyIoInitExpression)
        #elseif($di.method.returnType.dtoBeanWithInputIoProperty)
            #declareAndInitLocalVarBeanWithAltIo($di.method.returnType, true, false, false)
        #else
            #declareAndInitLocalVarImpl($di.method.returnType, $di.method.returnType.emptyIoInitExpression, false)
        #end
    #end
    #set($macro.returnTypeExpression = "#if($macro.shouldStoreInReference)$di.method.returnType.testClassLocalFieldName#else $di.method.returnType.emptyIoInitExpression #end")
    #if($macro.hasInnerWildcardType)
        $doReturn($macro.returnTypeExpression).$when($macro.qualifier).#methodCall($di.method, false);
    #else
        $when($macro.qualifier.#methodCall($di.method, false)).$thenReturn($macro.returnTypeExpression);
    #end
    #if($macro.shouldStoreInReference) $Newline #end
#end

##----------------------------------------------------------------------------------------------------------------------
## renderBrokenIoStub($di)
## Configures the provided dependency interaction ($di) to return either null or an absent value.
## Param: $di - the dependency interaction to be configured to return an absent value.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderBrokenIoStub $di)
    #set($macro.sourceVar = $di.field.possibleSourceVariables.intersection($dependencies).first)
    #set($macro.qualifier = "#if($shouldSetPackageLocalFields)${sourceClass.testClassMemberName}.${macro.sourceVar.declaredName}#else $macro.sourceVar.testClassMemberName #end")
    #set($macro.hasInnerWildcardType = $di.method.returnType.parameters.containsAnyWith('wildcard', true))
    #set($macro.isListenableFuture = $ListenableFutureNames.contains($di.method.returnType.canonicalName))
    #set($macro.shouldStoreInReference = true)
    #if($macro.shouldStoreInReference)

        // Configure ${di.field.type.name}.${di.method.name}(...).
        #if($macro.isListenableFuture)
            #declareAndInitListenableFuture($di.method.returnType, $di.method.returnType.parameters.first.brokenIoInitExpression)
        #elseif($di.method.returnType.dtoBeanWithInputIoProperty)
            #declareAndInitLocalVarBeanWithAltIo($di.method.returnType, false, true, false)
        #else
            #declareAndInitLocalVarImpl($di.method.returnType, $di.method.returnType.brokenIoInitExpression, false)
        #end
    #end
    #set($macro.returnTypeExpression = "#if($macro.shouldStoreInReference)$di.method.returnType.testClassLocalFieldName#else $di.method.returnType.brokenIoInitExpression #end")
    #if($macro.hasInnerWildcardType)
        $doReturn($macro.returnTypeExpression).$when($macro.qualifier).#methodCall($di.method, false);
    #else
        $when($macro.qualifier.#methodCall($di.method, false)).$thenReturn($macro.returnTypeExpression);
    #end
    #if($macro.shouldStoreInReference) $Newline #end
#end

##----------------------------------------------------------------------------------------------------------------------
## renderEmptyStub($di)
## Configures the provided dependency interaction ($di) to return an empty value.
## Param: $di - the dependency interaction to be configured to return an empty value.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderEmptyStub $di)
    #set($macro.sourceVar = $di.field.possibleSourceVariables.intersection($dependencies).first)
    #set($macro.qualifier = "#if($shouldSetPackageLocalFields)${sourceClass.testClassMemberName}.${macro.sourceVar.declaredName}#else $macro.sourceVar.testClassMemberName #end")
    #set($macro.hasInnerWildcardType = $di.method.returnType.parameters.containsAnyWith('wildcard', true))
    #set($macro.isListenableFuture = $ListenableFutureNames.contains($di.method.returnType.canonicalName))
    #set($macro.emptyInitExpressionIsLong = $di.method.returnType.emptyInitExpression && $ClassUtils.removePackageQualifiers($di.method.returnType.emptyInitExpression).length() > 40)
    #set($macro.shouldStoreInReference = ($di.method.returnType.shouldStoreInReference && ($di.method.returnType.shouldBeMocked || $macro.emptyInitExpressionIsLong)) || $di.method.returnType.shouldBeSpied || $macro.isListenableFuture)
    #if($macro.shouldStoreInReference)

        // Configure ${di.field.type.name}.${di.method.name}(...).
        #if($macro.isListenableFuture)
            #declareAndInitListenableFuture($di.method.returnType, $di.method.returnType.parameters.first.emptyInitExpression)
        #elseif($di.method.returnType.shouldBeSpied || $macro.emptyInitExpressionIsLong)
            #declareAndInitLocalVarImpl($di.method.returnType, $di.method.returnType.emptyInitExpression, false)
        #else
            #declareAndInitLocalVar($di.method.returnType, false)
        #end
    #end
    #set($macro.returnTypeExpression = "#if($macro.shouldStoreInReference)$di.method.returnType.testClassLocalFieldName#else $di.method.returnType.emptyInitExpression #end")
    #if($macro.hasInnerWildcardType)
        $doReturn($macro.returnTypeExpression).$when($macro.qualifier).#methodCall($di.method, false);
    #else
        $when($macro.qualifier.#methodCall($di.method, false)).$thenReturn($macro.returnTypeExpression);
    #end
    #if($macro.shouldStoreInReference) $Newline #end
#end

##----------------------------------------------------------------------------------------------------------------------
## renderFailureStub($di)
## Configures the provided dependency interaction ($di) to return an empty value.
## Param: $di - the dependency interaction to be configured to return an empty value.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderFailureStub $di)
    #set($macro.sourceVar = $di.field.possibleSourceVariables.intersection($dependencies).first)
    #set($macro.qualifier = "#if($shouldSetPackageLocalFields)${sourceClass.testClassMemberName}.${macro.sourceVar.declaredName}#else $macro.sourceVar.testClassMemberName #end")
    #set($macro.hasInnerWildcardType = $di.method.returnType.parameters.containsAnyWith('wildcard', true))
    #set($macro.isListenableFuture = $ListenableFutureNames.contains($di.method.returnType.canonicalName))
    #set($macro.isStandardFuture = $StringUtils.equalsAny($di.method.returnType.canonicalName, 'java.util.concurrent.Future', 'java.util.concurrent.CompletableFuture', 'java.util.concurrent.CompletionStage'))
    #set($macro.shouldStoreInReference = $di.method.returnType.shouldStoreInReference || $di.method.returnType.shouldBeSpied || $macro.isListenableFuture || ($macro.isStandardFuture && !$di.method.returnType.failureInitExpression))
    #if($macro.shouldStoreInReference)

        // Configure ${di.field.type.name}.${di.method.name}(...).
        #if($macro.isListenableFuture)
            #declareAndInitListenableFutureFailureCase($di.method.returnType)
        #elseif($macro.isStandardFuture && !$di.method.returnType.failureInitExpression)
            #declareAndInitCompletableFutureFailureCase($di.method.returnType)
        #else
            #declareAndInitLocalVarImpl($di.method.returnType, $di.method.returnType.failureInitExpression, false)
        #end
    #end
    #set($macro.returnTypeExpression = "#if($macro.shouldStoreInReference)$di.method.returnType.testClassLocalFieldName#else $di.method.returnType.failureInitExpression #end")
    #if($macro.hasInnerWildcardType)
        $doReturn($macro.returnTypeExpression).$when($macro.qualifier).#methodCall($di.method, false);
    #else
        $when($macro.qualifier.#methodCall($di.method, false)).$thenReturn($macro.returnTypeExpression);
    #end
    #if($macro.shouldStoreInReference) $Newline #end
#end

##----------------------------------------------------------------------------------------------------------------------
## declareAndInitLocalVar($param, $addNewlineAfterBean)
## Declares and initializes a local variable for $param. If $param is a DTOBean, Squaretest will initialize its
## properties. Squaretest also initializes any DTOBeans required for the $param's initialization expression.
## Param: $param               - the Type or Variable to declare and initialize.
## Param: $addNewlineAfterBean - boolean indicating whether a newline should be added after bean init code (or false).
##----------------------------------------------------------------------------------------------------------------------
#macro(declareAndInitLocalVar $param, $addNewlineAfterBean = false)
    #if($ListenableFutureNames.contains($param.type.canonicalName))
        #declareAndInitListenableFuture($param, false)
    #else
        #declareAndInitLocalVarImpl($param, false, $addNewlineAfterBean)
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## declareAndInitLocalVarImpl($param, $addNewlineAfterBean)
## The implementation for declareAndInitLocalVar(..).
## Param: $param - the Type or Variable to declare and initialize.
## Param: $initExpressionToUse (optional) - The init expression to use inline for the $param (or false).
## Param: $addNewlineAfterBean - boolean indicating whether a newline should be added after bean init code (or false).
##----------------------------------------------------------------------------------------------------------------------
#macro(declareAndInitLocalVarImpl $param, $initExpressionToUse = false, $addNewlineAfterBean = false)
    #set($macro.isOrHasBean = $param.type.dtoBean || !$param.type.initExpressionBeans.empty)
    #set($_ = $CodeStyleUtils.updateLocalFieldNameWithMethodScope($param))
    #if($initExpressionToUse)
        final $param.type.canonicalText $param.testClassLocalFieldName = $initExpressionToUse;
    #elseif($param.type.dtoBean)
        final $param.type.canonicalText $param.testClassLocalFieldName = $param.type.initExpression;
        #renderBeanSetupCodeForVar($param, false, false)
        #if($addNewlineAfterBean) $Newline #end
    #elseif(!$param.type.initExpressionBeans.empty)
        ## The parameter's initExpression has one or more beans; e.g. the bean in Optional.of(bean).
        ## Declare and init the beans first.
        #foreach($beanType in $param.type.initExpressionBeans)
            ## Declare the local field for the bean and initialize it.
            #declareAndInitLocalVar($beanType, false)
        #end
        #set($param.type.initExpression = $param.type.createInitExpressionWithLocalFieldBeans($param.type.initExpressionBeans))
        final $param.type.canonicalText $param.testClassLocalFieldName = $param.type.initExpression;
    #else
        final $param.type.canonicalText $param.testClassLocalFieldName = $param.type.initExpression;
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## declareAndInitLocalVarBeanWithAltIo($param, $shouldUseEmptyIo, $shouldUseBrokenIo, $addNewlineAfterBean)
## Declares and initializes a bean using an alternate IO init expression for its IO property.
## Param: $param             - the Type or Variable to declare and initialize.
## Param: $shouldUseEmptyIo  - boolean indicating whether or not to initialize the IO property to the empty IO variant.
## Param: $shouldUseBrokenIo - boolean indicating whether or not to initialize the IO property to the broken IO variant.
## Param: $addNewlineAfterBean - boolean indicating whether a newline should be added after bean init code (or false).
##----------------------------------------------------------------------------------------------------------------------
#macro(declareAndInitLocalVarBeanWithAltIo $param, $shouldUseEmptyIo, $shouldUseBrokenIo, $addNewlineAfterBean = false)
    #set($_ = $CodeStyleUtils.updateLocalFieldNameWithMethodScope($param))
    final $param.type.canonicalText $param.testClassLocalFieldName = $param.type.initExpression;
    #renderBeanSetupCodeForVar($param, $shouldUseEmptyIo, $shouldUseBrokenIo)
    #if($addNewlineAfterBean) $Newline #end
#end

##----------------------------------------------------------------------------------------------------------------------
## declareAndInitListenableFuture($param, $innerTypeInitExpression)
## Declares and initializes a ListenableFuture or SettableFuture.
## Param: $param                               - the Type or Variable to declare and initialize.
## Param: $innerTypeInitExpression (optional)  - The init expression to use for the Future's type parameter (or false).
##----------------------------------------------------------------------------------------------------------------------
#macro(declareAndInitListenableFuture $param, $innerTypeInitExpression = false)
    #set($_ = $CodeStyleUtils.updateLocalFieldNameWithMethodScope($param))
    #set($macro.shouldSetInnerType = $innerTypeInitExpression || !$param.type.parameters.first.canonicalText.equals('?'))
    #set($macro.shouldStoreInnerTypeInVar = !$innerTypeInitExpression && $macro.shouldSetInnerType && !$param.type.parameters.first.simple)
    #set($macro.settableFutureInfo = $ListenableFutureToSettableFutureMap.get("$param.type.canonicalName"))
    #if($macro.shouldStoreInnerTypeInVar)
        #declareAndInitLocalVar($param.type.parameters.first, false)
    #end
    final $macro.settableFutureInfo[0]<$param.type.parameters.first.canonicalText> $param.testClassLocalFieldName = $macro.settableFutureInfo[1];
    #if($macro.shouldSetInnerType)
        #if($innerTypeInitExpression)
            ${param.testClassLocalFieldName}.set($innerTypeInitExpression);
        #elseif($macro.shouldStoreInnerTypeInVar)
            ${param.testClassLocalFieldName}.set($param.type.parameters.first.testClassLocalFieldName);
        #else
            ${param.testClassLocalFieldName}.set($param.type.parameters.first.initExpression);
        #end
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## declareAndInitListenableFutureFailureCase($param)
## Declares and initializes a ListenableFuture or SettableFuture with an Exception result.
## Param: $param - the Type or Variable to declare and initialize.
##----------------------------------------------------------------------------------------------------------------------
#macro(declareAndInitListenableFutureFailureCase $param)
    #set($_ = $CodeStyleUtils.updateLocalFieldNameWithMethodScope($param))
    #set($macro.settableFutureInfo = $ListenableFutureToSettableFutureMap.get("$param.type.canonicalName"))
    final $macro.settableFutureInfo[0]<$param.type.parameters.first.canonicalText> $param.testClassLocalFieldName = $macro.settableFutureInfo[1];
    ${param.testClassLocalFieldName}.setException(new java.lang.Exception("message"));
#end

##----------------------------------------------------------------------------------------------------------------------
## declareAndInitCompletableFutureFailureCase($param)
## Declares and initializes a Future or CompletableFuture with an Exception result. This is needed to support Java 8.
## In Java 9+ CompletableFuture.failedFuture(exception) is used to construct the future with an exception result.
## Param: $param - the Type or Variable to declare and initialize.
##----------------------------------------------------------------------------------------------------------------------
#macro(declareAndInitCompletableFutureFailureCase $param)
    #set($_ = $CodeStyleUtils.updateLocalFieldNameWithMethodScope($param))
    final java.util.concurrent.CompletableFuture<$param.type.parameters.first.canonicalText> $param.testClassLocalFieldName = new java.util.concurrent.CompletableFuture<>();
    ${param.testClassLocalFieldName}.completeExceptionally(new java.lang.Exception("message"));
#end

##----------------------------------------------------------------------------------------------------------------------
## renderBeanSetupCodeForVar($param, $shouldUseEmptyIo, $shouldUseBrokenIo)
## Renders the code necessary to configure the provided bean.
## Param: $param - the Type or Variable for which to render the bean setup code.
## Param: $shouldUseEmptyIo  - boolean indicating whether or not to initialize the IO property to the empty IO variant.
## Param: $shouldUseBrokenIo - boolean indicating whether or not to initialize the IO property to the broken IO variant.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderBeanSetupCodeForVar $param, $shouldUseEmptyIo, $shouldUseBrokenIo)
    #set($macro.canonicalNamesInCallStack = {})
    #set($macro.canonicalNamesInCallStack[$param.type.canonicalName] = true)
    #set($macro.numberOfSettersCalled = $MutableInt.create(0))
    #renderBeanSetupCodeRecursively($param, $BeanContext.create($param, $minNumberOfSettersToCall, $maxNumberOfSettersToCall), $shouldUseEmptyIo, $shouldUseBrokenIo, $macro.canonicalNamesInCallStack, $macro.numberOfSettersCalled)
#end

##----------------------------------------------------------------------------------------------------------------------
## renderBeanSetupCodeRecursively(..)
## This should only be called from the #renderBeanSetupCodeForVar() macro.
## Renders the code necessary to configure the provided bean and its properties that are beans or lists of beans.
## Param: $typeOrVariable         - the Type or Variable for which to render the bean setup code.
## Param: $beanContext            - the context describing how to initialize the top level bean and its sub beans.
## Param: $shouldUseEmptyIo  - boolean indicating whether or not to initialize the IO property to the empty IO variant.
## Param: $shouldUseBrokenIo - boolean indicating whether or not to initialize the IO property to the broken IO variant.
## Param: $canonicalNamesInCallStack - the canonical names of beans in the recursive init call stack. This is used to
##        avoid infinite recursive loops.
## Param: $numberOfSettersCalled     - MutableInt containing the total number of setters called in this recurisve call.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderBeanSetupCodeRecursively $typeOrVariable, $beanContext, $shouldUseEmptyIo, $shouldUseBrokenIo, $canonicalNamesInCallStack, $numberOfSettersCalled)
    #set($macro.beanClass = $ClassUtils.resolveBean($beanContext, $typeOrVariable))
    #if(!$macro.beanClass)#break #end
    #set($macro.beanClass.testClassLocalFieldName = $typeOrVariable.testClassLocalFieldName)
    #set($macro.preferredSetters = $macro.beanClass.preferredInitMethods)
    #foreach($setter in $macro.preferredSetters)
        #if($numberOfSettersCalled.intValue() >= $beanContext.maxSettersToCall)#break #end
        #set($_ = $numberOfSettersCalled.increment())
        #if($setter.jaxbListGetter)
            #set($macro.param = $setter.returnType)
        #else
            #set($macro.param = $setter.parameters.first)
        #end
        #if($macro.param.type.generic && $typeOrVariable.type.parameters.size() == 1 && !$typeOrVariable.type.parameters.first.generic)
            #set($macro.param = $typeOrVariable.type.parameters.first)
        #end
        #if($macro.param.type.dtoBean)
            #if(!$canonicalNamesInCallStack[$macro.param.type.canonicalName])
                #set($_ = $CodeStyleUtils.updateLocalFieldNameWithMethodScope($macro.param))
                final $macro.param.type.canonicalText $macro.param.testClassLocalFieldName = $macro.param.initExpression;
                ## Store the beans cannonical name in map to avoid entering a recursive loop.
                #set($canonicalNamesInCallStack[$macro.param.type.canonicalName] = true)
                #renderBeanSetupCodeRecursively($macro.param, $beanContext, false, false, $canonicalNamesInCallStack, $numberOfSettersCalled)
                #set($canonicalNamesInCallStack[$macro.param.type.canonicalName] = false)
                #set($macro.param.shouldStoreInReference = true)
            #else
                #set($macro.param.shouldStoreInReference = false)
            #end
        #elseif(!$macro.param.type.initExpressionBeans.empty)
            ## The setter's param's initExpression contains at least one bean.
            #foreach($beanType in $macro.param.type.initExpressionBeans)
                #if(!$canonicalNamesInCallStack[$beanType.canonicalName])
                    #set($_ = $CodeStyleUtils.updateLocalFieldNameWithMethodScope($beanType))
                    final $beanType.canonicalText $beanType.testClassLocalFieldName = $beanType.initExpression;
                    #set($canonicalNamesInCallStack[$beanType.canonicalName] = true)
                    #renderBeanSetupCodeRecursively($beanType, $beanContext, false, false, $canonicalNamesInCallStack, $numberOfSettersCalled)
                    #set($canonicalNamesInCallStack[$beanType.canonicalName] = false)
                    #set($beanType.shouldStoreInReference = true)
                #else
                    #set($beanType.shouldStoreInReference = false)
                #end
            #end
            #set($macro.param.type.initExpression = $macro.param.type.createInitExpressionWithLocalFieldBeans($macro.param.type.initExpressionBeans.filter('shouldStoreInReference')))
            #set($macro.param.shouldStoreInReference = false)
        #else
            #set($macro.param.shouldStoreInReference = false)
        #end
        #if($setter.jaxbListGetter)
            ${macro.beanClass.testClassLocalFieldName}.${setter.name}().addAll($macro.param.type.initExpression);
        #elseif($shouldUseEmptyIo && $macro.param.type.emptyIoInitExpression)
            ${macro.beanClass.testClassLocalFieldName}.${setter.name}($macro.param.type.emptyIoInitExpression);
        #elseif($shouldUseBrokenIo && $macro.param.type.brokenIoInitExpression)
            ${macro.beanClass.testClassLocalFieldName}.${setter.name}($macro.param.type.brokenIoInitExpression);
        #else
            #if($macro.param.shouldStoreInReference)
                ${macro.beanClass.testClassLocalFieldName}.${setter.name}($macro.param.testClassLocalFieldName);
            #else
                ${macro.beanClass.testClassLocalFieldName}.${setter.name}($macro.param.type.initExpression);
            #end
        #end
    #end
    #renderExtraBeanSetupCode($macro.beanClass)
#end

##----------------------------------------------------------------------------------------------------------------------
## renderExtraBeanSetupCode($beanSourceClass)
## Renders any extra statements needed to initialize the instance of the $beanSourceClass.
## Param: $beanSourceClass - the SourceClass for the bean to render extra initialization code for.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderExtraBeanSetupCode $beanSourceClass)
    #if($StringUtils.equalsAny($beanSourceClass.type.canonicalName, 'com.amazonaws.services.s3.model.PresignedUrlDownloadResult'))
        final com.amazonaws.services.s3.model.S3Object spyS3Object = spy(new com.amazonaws.services.s3.model.S3Object());
        spyS3Object.setBucketName("bucketName");
        spyS3Object.setKey("key");
        spyS3Object.setObjectContent(new java.io.ByteArrayInputStream("objectContent".getBytes()));
        ${beanSourceClass.testClassLocalFieldName}.setS3Object(spyS3Object);
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## renderVerifyStatements($testInfo)
## Renders verify statements for the given test case.
## Param: $testInfo - information about which case this test should cover.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderVerifyStatements $testInfo)
    #if(!$generateStubsAndVerifyStatements)#break #end
    #foreach($di in $testInfo.mockedDIs)
        #if($testInfo.shouldReturnAbsent($di))
            #if($di.method.inferredNullable && $di.method.returnType.shouldBeSpied)
                ## Do nothing. The DI normally returns a closeable. It's returning null in this case, so no verify(..) is needed.
            #elseif($di.returnValueIgnored || $di.method.returnType.shouldBeSpied)
                #renderPrimaryFlowVerifyStatement($di)
            #end
        #elseif($testInfo.shouldReturnEmpty($di))
            #if($di.method.returnType.shouldBeSpied || $di.returnValueIgnored)
                #renderPrimaryFlowVerifyStatement($di)
            #end
        #elseif($testInfo.shouldReturnEmptyIo($di))
            #if($di.method.returnType.shouldBeSpied || $di.returnValueIgnored)
                #renderPrimaryFlowVerifyStatement($di)
            #end
        #elseif($testInfo.shouldReturnBrokenIo($di))
            #if($di.method.returnType.shouldBeSpied)
                #renderPrimaryFlowVerifyStatement($di)
            #end
        #elseif($testInfo.shouldThrowException($di))
            ## Do nothing.
        #elseif($testInfo.shouldReturnFailure($di))
            #if($di.returnValueIgnored || $di.method.returnType.closeable)
                #renderPrimaryFlowVerifyStatement($di)
            #end
        #else
            #renderPrimaryFlowVerifyStatement($di)
        #end
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## renderPrimaryFlowVerifyStatements($dis)
## Renders primary flow verify statements for the given dependency interactions ($dis).
## Param: $dis - the dependency interactions to render the primary flow verify statements for.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderPrimaryFlowVerifyStatements $dis)
    #foreach($di in $dis)
        #renderPrimaryFlowVerifyStatement($di)
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## renderPrimaryFlowVerifyStatement($di)
## Renders primary flow verify statement for the given dependency interactions ($di).
## Param: $di - the dependency interactions to render the primary flow verify statement for.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderPrimaryFlowVerifyStatement $di)
    #set($macro.sourceVar = $di.field.possibleSourceVariables.intersection($dependencies).first)
    #set($macro.qualifier = "#if($shouldSetPackageLocalFields)${sourceClass.testClassMemberName}.${macro.sourceVar.declaredName}#else $macro.sourceVar.testClassMemberName #end")
    #if(!$di.method.returnType)
        #if($shouldUseMockitoBdd)
            then($macro.qualifier).should().#methodCall($di.method, false);
        #else
            verify($macro.qualifier).#methodCall($di.method, false);
        #end
    #elseif($di.method.returnType.closeable && $di.method.returnType.shouldStoreInReference)
        #if($shouldUseMockitoBdd)
            then($di.method.returnType.testClassLocalFieldName).should().close();
        #else
            verify($di.method.returnType.testClassLocalFieldName).close();
        #end
    #elseif($di.returnValueIgnored)
        #if($shouldUseMockitoBdd)
            then($macro.qualifier).should().#methodCall($di.method, false);
        #else
            verify($macro.qualifier).#methodCall($di.method, false);
        #end
    #end
    #renderExtraVerifyStatements($di)
#end

##----------------------------------------------------------------------------------------------------------------------
## renderExtraVerifyStatements($di)
## Renders any extra verify statements needed for the provided dependency interaction.
## Param: $di - the dependency interactions to render the primary flow verify statement for.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderExtraVerifyStatements $di)
    #if($StringUtils.equalsAny($di.method.returnType.canonicalName, 'com.amazonaws.services.s3.model.PresignedUrlDownloadResult'))
        #if($shouldUseMockitoBdd)
            then(spyS3Object).should().close();
        #else
            verify(spyS3Object).close();
        #end
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## methodCall($method, $assumeArgsAreStoredInMembers)
## Renders an expression to call the given method. This does not include any qualifiers required to reference
## the method.
## Param: $method - the method or constructor for which to render the call-expression.
## Param: $assumeArgsAreStoredInMembers (optional) - assumes the arguments are stored in member fields instead of
##        local fields.
## Note: This macro uses multiline comments: #* and *# to avoid adding newlines.
##----------------------------------------------------------------------------------------------------------------------
#macro(methodCall $method, $assumeArgsAreStoredInMembers = false)#*
    *#${method.name}#if($method.constructor && $sourceClass.hasGenerics)<>#end#*
    *#(#foreach($param in $method.parameters)#*
        *##if(!$param.shouldStoreInReference)#*
            *#$param.initExpression#*
        *##elseif($assumeArgsAreStoredInMembers)#*
            *#$param.testClassMemberName#*
        *##else#*
            *#$param.testClassLocalFieldName#*
        *##end#*
        *##if($foreach.hasNext),#end#*
    *##end)#*
*##end

##----------------------------------------------------------------------------------------------------------------------
## determineTestCaseSuffix($testInfo)
## Determines the suffix to use for the given test case and stores the result in $testCaseSuffix.
## Param: $testInfo - information about which case this test should cover.
## Out:   $testCaseSuffix - the suffix to use for this test case.
##----------------------------------------------------------------------------------------------------------------------
#macro(determineTestCaseSuffix $testInfo)
    #set($macro.disToUse = $modelAttributeProviderMethodDIs.concat($testInfo.method.dependencyInteractions).satisfiedBy($dependencies.filter('shouldBeMocked')))
    #if($testInfo.subjectDi)
        #if($macro.disToUse.filterOutItemsWithSameSourceVar($testInfo.subjectDi).containsAnyWith('field.type.name', $testInfo.subjectDi.field.type.name))
            #set($macro.fieldName = "$StringUtils.capitalize($testInfo.subjectDi.field.declaredNameWithoutPrefix)")
        #else
            #set($macro.fieldName = "${testInfo.subjectDi.field.type.name}")
        #end
        #if($macro.disToUse.filterItemsWithSameSourceVar($testInfo.subjectDi).size() > 1)
            #set($macro.descriptionPart1 = "${macro.fieldName}$StringUtils.capitalize($testInfo.subjectDi.method.name)")
        #else
            #set($macro.descriptionPart1 = "${macro.fieldName}")
        #end
    #end
    #if($testInfo.paramWithEmptyIo)
        #set($testCaseSuffix = '_Empty' + $StringUtils.capitalize($testInfo.paramWithEmptyIo.declaredName))
    #elseif($testInfo.paramWithBrokenIo)
        #set($testCaseSuffix = '_Broken' + $StringUtils.capitalize($testInfo.paramWithBrokenIo.declaredName))
    #elseif($testInfo.subjectDiExceptionToThrow)
        #set($testCaseSuffix = "${macro.descriptionPart1}Throws${testInfo.subjectDiExceptionToThrow.type.name}")
    #elseif($testInfo.subjectDiReturnsFailure)
        #if($StringUtils.containsIgnoreCase($testInfo.subjectDi.method.returnType.failureInitExpression, 'Error'))
            #set($macro.returnSuffix = 'ReturnsError')
        #else
            #set($macro.returnSuffix = 'ReturnsFailure')
        #end
        #set($testCaseSuffix = "${macro.descriptionPart1}" + $macro.returnSuffix)
    #elseif($testInfo.subjectDiReturnsEmpty)
        #set($testCaseSuffix = "${macro.descriptionPart1}" + 'ReturnsNoItems')
    #elseif($testInfo.subjectDiReturnsEmptyIo)
        #set($testCaseSuffix = "${macro.descriptionPart1}" + 'ReturnsNoContent')
    #elseif($testInfo.subjectDiReturnsBrokenIo)
        #set($testCaseSuffix = "${macro.descriptionPart1}" + 'ReturnsBrokenIo')
    #elseif($testInfo.subjectDiReturnsAbsent)
        #if($testInfo.subjectDi.method.inferredNullable)
            #set($macro.returnSuffix = 'ReturnsNull')
        #elseif($testInfo.subjectDi.method.returnType.optional)
            #set($macro.returnSuffix = 'ReturnsAbsent')
        #else
            #set($macro.returnSuffix = 'ReturnsNoItem')
        #end
        #set($testCaseSuffix = "${macro.descriptionPart1}" + $macro.returnSuffix)
    #elseif($testInfo.expectedException)
        #set($testCaseSuffix = "Throws${testInfo.expectedException.type.name}")
    #else
        #set($testCaseSuffix = '')
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## renderTestMethodForEnum($testInfo)
## Renders the enum test method for the given Method. This is similar to #renderTestMethod($method) but calls the
## method on each value in the enum and adds an assertEquals call for each result.
## Param: $testInfo - information about which case this test should cover.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderTestMethodForEnum $testInfo)
    #set($macro.multipleValuesTest = $sourceClass.enumValues.size() > 1 && !$testInfo.method.static)
    #set($macro.paramsToStoreInFields = $testInfo.method.parameters.filter('shouldStoreInReference', true))
    #set($macro.shouldRenderSetup = $macro.paramsToStoreInFields.size() > 0 || ($testInfo.method.returnType && !$testInfo.expectedException))
    #determineTestCaseSuffix($testInfo)
    #set($macro.returnTypeIsArrayWithComparableType = $testInfo.method.returnType.array && ($testInfo.method.returnType.deepArrayComponentType.primitive || $testInfo.method.returnType.deepArrayComponentType.overridesEquals))
    #set($macro.shouldCreateAssertEqualsCall =
        !$macro.multipleValuesTest && $testInfo.method.returnType && ($testInfo.method.returnType.primitive || $testInfo.method.returnType.overridesEquals || $testInfo.method.returnType.array)
        && ($testInfo.method.returnType.classT || $testInfo.method.returnType.allNestedTypeParamsOverrideEquals || $macro.returnTypeIsArrayWithComparableType)
        && !$testInfo.expectedException)
    #set($macro.shouldStoreExpectedValue = $macro.shouldCreateAssertEqualsCall && !$testInfo.method.returnType.simple)
    #set($macro.shouldRenderSimpleMultivalueTest = $macro.multipleValuesTest && ($testInfo.method.returnType || $testInfo.expectedException))
    #if($macro.shouldRenderSimpleMultivalueTest)
        #renderSimpleMultivalueTestMethodForEnum($testInfo)
        #break($macro)
    #end
    @Test
    void ${method.name}${testInfo.method.overloadSuffix}${testCaseSuffix}Test()
            throws Exception {
        #if($macro.shouldRenderSetup)
            // Setup
            ## Declare parameters to use to invoke the method.
            #foreach($param in $macro.paramsToStoreInFields)
                #if($param == $testInfo.paramWithEmptyIo)
                    #declareAndInitLocalVarImpl($param, $param.type.emptyIoInitExpression, true)
                #elseif($param == $testInfo.paramWithBrokenIo)
                    #declareAndInitLocalVarImpl($param, $param.type.brokenIoInitExpression, true)
                #else
                    #declareAndInitLocalVar($param, true)
                #end
            #end
            #if($macro.shouldStoreExpectedValue)
                #declareAndInitLocalVar($testInfo.method.returnType, true)
            #end

        #end
        // Run the test
        #set($macro.qualifier = "#if($testInfo.method.static)${sourceClass.canonicalNameOrName}#else${sourceClass.canonicalNameOrName}.${sourceClass.enumFirstValue}#end")
        #if($testInfo.expectedException)
            assertThatThrownBy(() -> ${macro.qualifier}.#methodCall($testInfo.method, false)).isInstanceOf(${testInfo.expectedException.type.canonicalNameOrName}.class);
        #elseif($macro.multipleValuesTest)
            #foreach($enumValue in $sourceClass.enumValues)
                ${sourceClass.canonicalNameOrName}.${enumValue}.#methodCall($testInfo.method, false);
            #end
        #else
            #if($testInfo.method.returnType) final $testInfo.method.returnType.canonicalText result = #end ${macro.qualifier}.#methodCall($testInfo.method, false);
        #end
        #if(!$testInfo.expectedException)

            // Verify the results
            #if($macro.shouldCreateAssertEqualsCall)
                #set($macro.expectedValueExpression = "#if($macro.shouldStoreExpectedValue)$testInfo.method.returnType.testClassLocalFieldName #else $testInfo.method.returnType.initExpression #end")
                #assertEqualsCall($macro.expectedValueExpression, 'result', $testInfo.method.returnType);
            #end
        #end
    }
#end

##----------------------------------------------------------------------------------------------------------------------
## renderSimpleMultivalueTestMethodForEnum($testInfo)
## Renders a simple test method for the given $testInfo. The method contains assertions for all
## values in the enum.
## Param: $testInfo - information about which case this test should cover.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderSimpleMultivalueTestMethodForEnum $testInfo)
    #set($testCaseSuffix = "#if($testInfo.expectedException)_Throws${testInfo.expectedException.type.name}#end")
    #foreach($param in $testInfo.method.parameters)
        #set($param.shouldStoreInReference = false)
    #end
    @Test
    void ${method.name}${testInfo.method.overloadSuffix}${testCaseSuffix}Test()
            throws Exception {
        #foreach($enumValue in $sourceClass.enumValues)
            #if($testInfo.expectedException)
                assertThatThrownBy(() -> ${sourceClass.canonicalNameOrName}.${enumValue}.#methodCall($testInfo.method, false)).isInstanceOf(${testInfo.expectedException.type.canonicalNameOrName}.class);
            #else
                ## There is a bug in the Velocity engine where macro calls in set statements don't work correctly when the
                ## VM_PERM_INLINE_LOCAL setting is enabled. To work around this, define a VTL block containing the macro call, then
                ## evaluate the block and assign the result in a set statement.
                #define($__workaroundCallExpression) ${sourceClass.canonicalNameOrName}.${enumValue}.#methodCall($testInfo.method, false) #end
                #set($macro.callExpression = "$__workaroundCallExpression")
                #assertEqualsCall($testInfo.method.returnType.initExpression, $macro.callExpression, $testInfo.method.returnType);
            #end
        #end
    }
#end

##----------------------------------------------------------------------------------------------------------------------
## renderSimpleTestMethod($method)
## Renders a simple test method for the given $method.
## Param: $method - the method for which to render the simple test method.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderSimpleTestMethod $method)
    #set($macro.allSourceMethodExceptions = $method.declaredExceptions.union($method.javadocExceptions, 'type.canonicalName'))
    #set($macro.shouldRenderAltFlowTests = $method.parameters.size() > 0)
    @Test
    void ${method.name}${method.overloadSuffix}()Test throws Exception {
    #set($macro.qualifier = "#if($method.static)${sourceClass.canonicalNameOrName}#else${sourceClass.testClassMemberName}#end")
    ## There is a bug in the Velocity engine where macro calls in set statements don't work correctly when the
    ## VM_PERM_INLINE_LOCAL setting is enabled. To work around this, define a VTL block containing the macro call, then
    ## evaluate the block and assign the result in a set statement.
    #define($__workaroundCallExpression) ${macro.qualifier}.#methodCall($method, false) #end
    #set($macro.callExpression = "$__workaroundCallExpression")
    #assertEqualsCall($method.returnType.initExpression, $macro.callExpression, $method.returnType);
    #if($macro.shouldRenderAltFlowTests)
        ## Render an assertNull(...) call if one is needed.
        #if($method.returnTypeCanBeAbsent)
            #if($method.inferredNullable)
                assertThat($macro.callExpression).isNull();
            #elseif($StringUtils.equalsAny($method.returnType.canonicalName, 'java.util.Optional', 'java.util.OptionalLong', 'java.util.OptionalInt', 'java.util.OptionalDouble'))
                assertThat($macro.callExpression).isEmpty();
            #elseif($method.returnType.overridesEquals)
                #assertEqualsCall($method.returnType.absentInitExpression, $macro.callExpression, $method.returnType);
            #end
        #end
        #if($method.returnType.emptyInitExpression)
            #assertEqualsCall($method.returnType.emptyInitExpression, $macro.callExpression, $method.returnType);
        #end
        ## Render an assertThatThrownBy(...) call for each exception declared by the method.
        #foreach($declaredException in $macro.allSourceMethodExceptions)
            assertThatThrownBy(() -> ${macro.qualifier}.#methodCall($method, false)).isInstanceOf(${declaredException.type.canonicalNameOrName}.class);
        #end
    #end
    }
#end

##----------------------------------------------------------------------------------------------------------------------
## Generates an inline mock expression to create a mock for type: $classToMock in a way that is consistent with the
## $useStaticImportForInitMocks quick setting.
## Param: $classToMock - the name or canonical name of the class to mock.
##----------------------------------------------------------------------------------------------------------------------
#macro(mock $classToMock)
    #if($useStaticImportForInitMocks)
        mock($classToMock)
    #else
        Mockito.mock($classToMock)
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## renderImportsForMatchers()
## Renders import statements for the mockito matchers; i.e. any(), eq(), etc.
## Matchers will be imported from org.mockito.ArgumentMatchers if it is available on the test classpath or if none of
## the mockito classes are on the test classpath. Otherwise, if org.mockito.Matchers is present on the classpath and
## org.mockito.ArgumentMatchers is not, Squaretest will import the matchers from org.mockito.Matchers.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderImportsForMatchers)
    #set($macro.matcherCanonicalName = 'org.mockito.ArgumentMatchers')
    #if((!$ClassUtils.isInTestClasspath($macro.matcherCanonicalName))
        && $ClassUtils.isInTestClasspath('org.mockito.Matchers'))
        #set($macro.matcherCanonicalName = 'org.mockito.Matchers')
    #end
    import static ${macro.matcherCanonicalName}.any;
    import static ${macro.matcherCanonicalName}.anyInt;
    import static ${macro.matcherCanonicalName}.anyString;
    import static ${macro.matcherCanonicalName}.eq;
#end

##----------------------------------------------------------------------------------------------------------------------
## initializeTemplateDataModel()
## Updates mutable fields in $sourceClass and $importLinesRequired based on the Quick Settings at the top of the file
## and the architype of the source class. This also sets additional variables used in the rendering logic.
## Using a macro to prepare the data model separates the test-class rendering-logic from the configuration and
## class architype-detection logic; this keeps the rendering logic simple and easy to modify.
##
## Global Variables Set by #initializeTemplateDataModel():
##
##   $dependencies                  a List<Variable> containing all fields the test class should provide for the
##                                  instance of the source class.
##   $memberFields                  a subset of $dependencies containing only fields that should be stored in members
##                                  in the test class.
##   $mockMemberFields              a subset of $memberFields containing only fields that should be mocked.
##
##   $nonMockMemberFields           a subset of $memberFields containing only fields that should not be mocked.
##
##   $sourceClassMemberNeeded       a boolean indicating whether or not an instance of the source class should be
##                                  created and stored in a member of the test class.
##   $shouldUseInjectMocks          a boolean indicating whether or not @InjectMocks should be used to provide
##                                  dependencies to the instance of the source class.
##   $shouldSetPackageLocalFields   a boolean indicating whether or not the test class should provide dependencies
##                                  to the source class by setting package-local fields.
##   $mocksNeeded                   true if source class has at least one dependency that should be mocked.
##
##   $shouldCreateTestsForInstanceMethods
##                                  a boolean indicating whether or not test should be created for the instance methods
##                                  in the source class.
##   $mockMvcMemberName             a String containing the name of the MockMvc member field.
##   $springController              a boolean indicating whether or not the class is a Spring controller.
##   $restController                a boolean indicating whether or not the class is a rest controller.
##   $hasClassSecurityAnnotations   a boolean indicating whether or not the class has Spring security annotations.
##   $basePath                      the base uri path for this contoller or '' if one is not set.
##   $controllerMethods             the list of controller methods in the class.
##   $modelAttributeProviderMethods the model attribute provider methods in the source class.
##   $modelAttributeProviderMethodDIs  the dependencyInteractions for the model attribute provider methods in the source class class.
##   $allModelAttributeProviderMethods all model attribute provider methods in this class and super classes.
##
##   Constants set by #initializeTemplateDataModel():
##
##   $BooleanTypes                  List of canonical names for boolean types (java.lang.Boolean and boolean)
##   $NumericTypes                  List of canonical names for numeric types (primitive and boxed).
##   $MultipartInterfaceTypes       Base types representing parts of a multipart request.
##   $IgnoredControllerTypes        Parameter types (canonical names) that should be ignored (skipped) when creating
##                                  tests for controller methods.
##   $RequestMappingAnnotations     The simple names of all RequestMapping annotations.
##   $ControllerMethodAnnotations   The simple names of all annotations that indicate that a method is a controller.
##   $ControllerParameterAnnotations The simple names of all annotations that can be on a controller method parameters.
##   $SecurityAnnotations           The simple names of all annotations that indicate a method or controller class
##                                  requires a user authenticated via the Spring security framework.
##----------------------------------------------------------------------------------------------------------------------
#macro(initializeTemplateDataModel)
    ## Define ListenableFuture to SettableFutures map.
    ## If your company uses a fork of ListenableFuture, add an entry here to improve test generation.
    ## The format is: 'ListenableFutureCanonicalName' : ['SettableFutureCanonicalName', 'SettableFutureInitExpression'].
    #set($ListenableFutureToSettableFutureMap = {
        'com.google.common.util.concurrent.ListenableFuture':
            ['com.google.common.util.concurrent.SettableFuture', 'com.google.common.util.concurrent.SettableFuture.create()'],
        'com.google.common.util.concurrent.SettableFuture':
            ['com.google.common.util.concurrent.SettableFuture', 'com.google.common.util.concurrent.SettableFuture.create()'],
        'com.google.api.core.ApiFuture':
            ['com.google.api.core.SettableApiFuture', 'com.google.api.core.SettableApiFuture.create()'],
        'com.google.api.core.SettableApiFuture':
            ['com.google.api.core.SettableApiFuture', 'com.google.api.core.SettableApiFuture.create()'],
        'org.springframework.util.concurrent.ListenableFuture':
            ['org.springframework.util.concurrent.SettableListenableFuture', 'new org.springframework.util.concurrent.SettableListenableFuture<>()'],
        'org.springframework.util.concurrent.SettableListenableFuture':
            ['org.springframework.util.concurrent.SettableListenableFuture', 'new org.springframework.util.concurrent.SettableListenableFuture<>()']
    })
    #set($ListenableFutureNames = $ListenableFutureToSettableFutureMap.keySet())
    ## Determine information about JUnit and Mockito versions on the test classpath.
    #set($hasOpenMocksMethod = false)
    #set($initMocksMethodName = 'initMocks')
    #set($macro.mockitoAnnotationsSourceClass = $ClassUtils.resolveClass('org.mockito.MockitoAnnotations'))
    #if($macro.mockitoAnnotationsSourceClass && $macro.mockitoAnnotationsSourceClass.methods.containsAnyWith('name', 'openMocks'))
        #set($hasOpenMocksMethod = true)
        #set($initMocksMethodName = 'openMocks')
    #end
    #set($BooleanTypes = ['boolean', 'java.lang.Boolean'])
    #set($NumericTypes = ['int', 'float', 'double', 'short', 'char', 'long', 'byte', 'java.lang.Number', 'java.lang.Character'])
    #set($MultipartInterfaceTypes = ['org.springframework.web.multipart.MultipartFile', 'javax.servlet.http.Part', 'org.springframework.http.codec.multipart.Part'])
    #set($IgnoredControllerTypes = ['org.springframework.web.context.request.WebRequest', 'javax.servlet.ServletRequest', 'javax.servlet.ServletResponse',
    'javax.servlet.http.HttpSession', 'javax.servlet.http.PushBuilder', 'org.springframework.http.HttpMethod', 'java.util.TimeZone', 'java.time.ZoneId',
    'java.io.InputStream', 'java.io.Reader', 'java.io.OutputStream', 'java.io.Writer', 'java.util.Map', 'org.springframework.ui.Model', 'org.springframework.ui.ModelMap',
    'org.springframework.web.servlet.mvc.support.RedirectAttributes', 'org.springframework.validation.Errors', 'org.springframework.web.bind.support.SessionStatus',
    'org.springframework.web.util.UriComponentsBuilder'])
    #set($RequestMappingAnnotations = ['DeleteMapping', 'GetMapping', 'PatchMapping', 'PostMapping', 'PutMapping', 'RequestMapping', 'NotificationMessageMapping'])
    #set($ControllerMethodAnnotations = ['DeleteMapping', 'GetMapping', 'PatchMapping', 'PostMapping', 'PutMapping', 'RequestMapping', 'ResponseBody', 'ResponseStatus', 'NotificationMessageMapping'])
    #set($SecurityAnnotations = ['PreAuthorize', 'PostAuthorize', 'PreFilter', 'PostFilter', 'Secured'])
    #set($ControllerParameterAnnotations = ['PathVariable', 'MatrixVariable', 'RequestParam', 'RequestHeader', 'CookieValue', 'RequestBody', 'RequestPart', 'ModelAttribute', 'SessionAttribute', 'RequestAttribute'])

    ## Determine if the source class is a Spring controller.
    #set($macro.superClasses = $FluentList.of($sourceClass).concat($sourceClass.allSuperClasses))
    #set($springController = $macro.superClasses.containsAnyWithAnnotation('org.springframework.stereotype.Controller', 'org.springframework.web.bind.annotation.RestController'))
    #set($restController = $macro.superClasses.containsAnyWithAnnotation('org.springframework.web.bind.annotation.RestController')
        || ($macro.superClasses.containsAnyWithAnnotation('org.springframework.stereotype.Controller') && $macro.superClasses.containsAnyWithAnnotation('org.springframework.web.bind.annotation.ResponseBody')))
    #set($hasClassSecurityAnnotations = $macro.superClasses.containsAnyWithAnnotation($SecurityAnnotations))

    ## Determine which methods in the source class are controller methods.
    #set($controllerMethods = $FluentList.of())
    #if($springController)
        #foreach($method in $sourceClass.methods)
            #if($method.hasAnnotation($ControllerMethodAnnotations)
                || ($method.superMethods.containsAnyWithAnnotation($ControllerMethodAnnotations)))
                #set($_ = $controllerMethods.add($method))
            #end
        #end
    #end
    #set($allModelAttributeProviderMethods = $macro.superClasses.flatMap('methods').filterItemsWithAnnotation('ModelAttribute').filterOutItemsWithAnnotation($ControllerMethodAnnotations))
    #set($modelAttributeProviderMethods = $sourceClass.methods.filterItemsWithAnnotation('ModelAttribute').filterOutItemsWithAnnotation($ControllerMethodAnnotations))
    #set($modelAttributeProviderMethodDIs = $allModelAttributeProviderMethods.flatMap('dependencyInteractions'))
    #if($springController && $sourceClass.preferredConstructor && !$sourceClass.preferredConstructor.hasAnnotation('Autowired'))
        ## Use the @Autowired constructor if available.
        #set($macro.newPreferredConstructor = $sourceClass.constructorsAnnotatedWith('Autowired').first)
        #if($macro.newPreferredConstructor)
            #set($sourceClass.preferredConstructor = $macro.newPreferredConstructor)
        #end
    #end
    ## Determine the base path for the controller class if there is one.
    #set($basePath = '')
    #set($macro.annotationPath = $macro.superClasses.flatMap('annotations').filter('name', 'RequestMapping').flatMap('parameters').filter('key', 'path', 'value').filterOut('value.text', '{}').first.value.text)
    ## Replace environment variable placeholders like ${companyName} with the String: companyName.
    #set($macro.tempBasePath = $StringUtils.replaceAll($macro.annotationPath, '\$\{(.*?)\}', '/$1/'))
    #set($macro.tempBasePath = $StringUtils.replaceAll($macro.tempBasePath, '/+', '/'))
    ## The path can be a String[] with multiple Strings. Take the longest substring between two double quote chars.
    #set($macro.tempBasePath = $StringUtils.longest($StringUtils.substringsBetween($macro.tempBasePath, '"')))
    #if($macro.tempBasePath)
        #set($basePath = $macro.tempBasePath)
    #elseif($macro.annotationPath)
        ## The path could be a reference to a constant; e.g. MyPaths.FooPath.
        #set($basePath = 'basePath')
    #end
    #set($mockMvcMemberName = "$CodeStyleUtils.suggestMemberName('MockMvc')")
    #if($shouldUseMockitoBdd)
        #set($doAnswer = 'willAnswer')
        #set($doReturn = 'willReturn')
        #set($thenReturn = 'willReturn')
        #set($when = 'given')
        #set($doThrow = 'willThrow')
        #set($thenThrow = 'willThrow')
    #else
        #set($doAnswer = 'doAnswer')
        #set($doReturn = 'doReturn')
        #set($thenReturn = 'thenReturn')
        #set($when = 'when')
        #set($doThrow = 'doThrow')
        #set($thenThrow = 'thenThrow')
    #end
    ## Determine the archetype of the source class and set the global variables accordingly.
    #set($shouldCreateTestsForInstanceMethods = true)
    #set($mutablePackageLocalInstanceFields = $sourceClass.packageLocalInstanceFields.filter('final', false))
    ## Add the simple names or cannonical names of any custom dependency annotations to the method call below.
    #set($dependencyAnnotatedFields = $sourceClass.fieldsAnnotatedWith('Inject', 'Autowired', 'Resource', 'PersistenceContext'))
    #if($sourceClass.enum)
        #set($dependencies = $FluentList.emptyList())
        #set($sourceClassMemberNeeded = false)
    #elseif($sourceClass.instanceMethods.empty && !$sourceClass.staticMethods.empty)
        ## The source class only has static methods; it's likely a utils class.
        #set($dependencies = $FluentList.emptyList())
        #set($sourceClassMemberNeeded = false)
    #elseif($sourceClass.abstract && !$sourceClass.packageVisibleStaticCreatorMethods.empty)
        ## The source class is abstract and has static creator methods. Only create tests for those. The static creator
        ## test methods invoke the instance methods.
        #set($dependencies = $FluentList.emptyList())
        #set($sourceClassMemberNeeded = false)
        #set($shouldCreateTestsForInstanceMethods = false)
    #elseif($sourceClass.sealedAbstract)
        ## The source class is a sealed abstract class. If we have a preferred constructor, use its arguments for the
        ## dependencies. That way the user can simply replace the constructor call with its appropriate subclass constructor call.
        #if($sourceClass.preferredConstructor)
            #set($dependencies = $sourceClass.preferredConstructor.parameters)
        #else
            #set($dependencies = $FluentList.emptyList())
        #end
        #set($sourceClassMemberNeeded = true)
    #elseif($sourceClass.abstract && !$sourceClass.preferredConstructor)
        ## The source class is an abstract class, but does not have a visible constructor or static creator methods.
        #set($dependencies = $FluentList.emptyList())
        #set($sourceClassMemberNeeded = true)
    #elseif($sourceClass.preferredConstructor && !$sourceClass.preferredConstructor.parameters.empty)
        ## The source class has a parameterized constructor; use it to provide the dependencies.
        #set($dependencies = $sourceClass.preferredConstructor.parameters)
        #set($sourceClassMemberNeeded = true)
    #elseif($sourceClass.preferredConstructor && !$dependencyAnnotatedFields.filter('private', true).empty)
        ## The source class has a no-args constructor and private fields annotated with @Inject or @Autowired.
        #set($shouldUseInjectMocks = true)
        #set($dependencies = $dependencyAnnotatedFields)
        #set($sourceClassMemberNeeded = true)
    #elseif($sourceClass.preferredConstructor && !$dependencyAnnotatedFields.empty)
        ## The source class has a no-args constructor and visible, dependency-annotated fields;
        ## the test class should set them.
        #set($dependencies = $dependencyAnnotatedFields)
        #set($shouldSetPackageLocalFields = true)
        #set($sourceClassMemberNeeded = true)
    #elseif($sourceClass.preferredConstructor && !$mutablePackageLocalInstanceFields.empty)
        ## The source class has a no-args constructor and mutable package-local instance fields; assume they are
        ## dependencies and have the test class set them.
        #set($dependencies = $mutablePackageLocalInstanceFields)
        #set($shouldSetPackageLocalFields = true)
        #set($sourceClassMemberNeeded = true)
    #elseif($sourceClass.preferredConstructor)
        ## The source class has a visible constructor but no package-local fields or dependency-annotated fields.
        #set($dependencies = $FluentList.emptyList())
        #set($sourceClassMemberNeeded = true)
    #elseif($sourceClass.singleton)
        #set($dependencies = $FluentList.emptyList())
        #set($sourceClassMemberNeeded = true)
    #elseif(!$sourceClass.packageVisibleStaticCreatorMethods.empty)
        ## The source class has no visible constructor, but does have static creator methods; e.g. parse(...), from(...).
        #set($dependencies = $FluentList.emptyList())
        #set($sourceClassMemberNeeded = false)
        #set($shouldCreateTestsForInstanceMethods = false)
    #else
        #set($dependencies = $FluentList.emptyList())
        #set($sourceClassMemberNeeded = true)
    #end
    #if($springController)
        #set($sourceClassMemberNeeded = false)
        #set($shouldSetPackageLocalFields = false)
    #end
    ## Update the mutable fields on the dependencies based on the Quick Settings.
    #setDependencyNamesAndInitExpressions($dependencies, $shouldUseInjectMocks, $shouldSetPackageLocalFields)
    ## Filter out fields that should not be stored as members in the test class.
    #set($memberFields = $dependencies.filter('shouldStoreInReference', true))
    #set($mockMemberFields = $memberFields.filter('shouldBeMocked', true))
    #set($nonMockMemberFields = $memberFields.filter('shouldBeMocked', false))
    #set($mocksNeeded = !$mockMemberFields.empty || $shouldUseInjectMocks)
    #initializeMethodParamsWithQuickSettings()
    #initializeMethodReturnTypes()
    #initializeDependencyInteractionMethodParams()
    #askUserToConfirmSettingsIfNeeded()
#end

##----------------------------------------------------------------------------------------------------------------------
## initializeMethodReturnTypes()
## Sets the returnType.testClassLocalFieldName of each method to 'expectedResult'.
##----------------------------------------------------------------------------------------------------------------------
#macro(initializeMethodReturnTypes)
    #foreach($method in $sourceClass.allMethods)
        #if($method.returnType)
            #if($sourceClass.packageVisibleStaticCreatorMethods.contains($method))
                #set($method.returnType.testClassLocalFieldName = 'result')
            #else
                #set($method.returnType.testClassLocalFieldName = 'expectedResult')
            #end
        #end
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## initializeMethodParamsWithQuickSettings()
## Sets mutable fields on the method parameters based on Quick Settings.
##----------------------------------------------------------------------------------------------------------------------
#macro(initializeMethodParamsWithQuickSettings)
    #foreach($method in $sourceClass.allMethods)
    #foreach($param in $method.parameters)
        #if($param.type.generic && $sourceClass.packageVisibleStaticCreatorMethods.contains($method))
            ## Use inline args for generic types in static creator methods; e.g. Pair.of(left, right), ImmutableList.of(T...).
            #set($param.shouldStoreInReference = false)
        #elseif($useMocksForListenerAndCallbackParameters
            && $param.type.mockable
            && ($StringUtils.endsWithIgnoreCase($param.declaredName, "listener")
                || $StringUtils.endsWithIgnoreCase($param.declaredName, "callback")))
            ## If useMocksForListenerAndCallbackParameters is set it takes precedence over any initExpressionOverrides.
            #if($param.used)
                #useInlineMockForParam($param)
                #set($param.shouldStoreInReference = true)
            #else
                #set($param.shouldStoreInReference = false)
            #end
        #elseif(!$param.used && $param.type.initExpression == 'null')
            #set($param.shouldStoreInReference = false)
        #elseif($initExpressionOverrides.containsKey($param.type.canonicalName))
            ## Check the initExpressionOverrides.
            #set($macro.initExpressionOverride = false)
            #set($macro.initExpressionOverride = $initExpressionOverrides.get($param.type.canonicalName))
            #if($macro.initExpressionOverride)
                #set($param.initExpression = $macro.initExpressionOverride.initExpression)
                #set($param.shouldStoreInReference = $macro.initExpressionOverride.shouldStoreInReference)
                #set($param.shouldBeMocked = false)
                #set($_ = $importLinesRequired.addAll($ListUtils.nullToEmpty($macro.initExpressionOverride.importsRequired)))
            #end
        #elseif($param.type.recognized && $param.type.shouldBeMocked)
            #useInlineMockForParam($param)
            #set($param.shouldStoreInReference = true)
        #else
            #set($param.shouldBeMocked = false)
        #end
        #setTestClassNamesForParam($param)
    #end
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## setDependencyNamesAndInitExpressions($dependencies, $shouldUseInjectMocks, $shouldSetPackageLocalFields)
## Sets mutable fields on the $params based on the Quick Settings.
## Param: $dependencies the List<Variable> containing the dependencies.
## Param: $shouldUseInjectMocks
##          a boolean indicating whether or not @InjectMocks should be used to provide dependencies to the instance
##          of the source class.
## Param: $shouldSetPackageLocalFields
##          a boolean indicating whether or not the test class should provide dependencies to the source class by
##          setting package-local fields.
##----------------------------------------------------------------------------------------------------------------------
#macro(setDependencyNamesAndInitExpressions $dependencies, $shouldUseInjectMocks, $shouldSetPackageLocalFields)
    #foreach($dependency in $dependencies)
        ## Use the initExpressionOverride if one is present and we do not need to use @InjectMocks.
        #set($macro.initExpressionOverride = false)
        #set($macro.initExpressionOverride = $initExpressionOverrides.get($dependency.type.canonicalName))
        #if($macro.initExpressionOverride && !$shouldUseInjectMocks)
            #set($dependency.initExpression = $macro.initExpressionOverride.initExpression)
            #set($dependency.shouldStoreInReference = $macro.initExpressionOverride.shouldStoreInReference)
            #set($dependency.shouldBeMocked = false)
            #set($_ = $importLinesRequired.addAll($ListUtils.nullToEmpty($macro.initExpressionOverride.importsRequired)))
        #elseif($shouldUseInjectMocks && $dependency.type.mockable)
            #set($dependency.shouldBeMocked = true)
            #set($dependency.shouldStoreInReference = true)
        #elseif(!$dependency.shouldBeMocked)
            #set($dependency.shouldStoreInReference = false)
        #end
        ## If the dependencies are provided by setting package-local fields, set them inline instead of storing
        ## references to them in the test class.
        #if($shouldSetPackageLocalFields)
            #if($dependency.shouldBeMocked)
                #useInlineMockForParam($dependency)
            #end
            #set($dependency.shouldStoreInReference = false)
        #end
        #setTestClassNamesForParam($dependency)
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## initializeDependencyInteractionMethodParams()
## Updates the data model to use inline initialization expressions for the method arguments in stub (when) and verify
## expressions.
##----------------------------------------------------------------------------------------------------------------------
#macro(initializeDependencyInteractionMethodParams)
    #foreach($method in $sourceClass.allMethods)
    #foreach($di in $method.dependencyInteractions)
        #initializeDependencyInteractionMethodReturnType($di)
        ## Set the parameter init expressions to either values or matcher expressions.
        #set($macro.hasCallableOrRunnableParam = $di.method.parameters.containsAnyWith('type.canonicalName', 'java.util.concurrent.Callable','java.lang.Runnable'))
        #set($macro.hasParamRequiringMatcher = $macro.hasCallableOrRunnableParam || $di.methodCallExpression.arguments.filterOut('actualType.primitive').filterOut('declaredType.classT').containsAnyWith('actualType.overridesEquals', false))
    #foreach($param in $di.method.parameters)
        #set($macro.actualType = $di.methodCallExpression.arguments.get($foreach.index).actualType)
        #set($param.shouldStoreInReference = false)
        ## Handle Callables and Runnables.
        #if($param.type.canonicalName == 'java.util.concurrent.Callable')
            #set($param.initExpression = '(Callable<?>) any(Callable.class)')
        #elseif($param.type.canonicalName == 'java.lang.Runnable')
            #set($param.initExpression = 'any(Runnable.class)')
        ## Handle Class<T> arguments; e.g. Foo.class.
        #elseif($param.type.classT)
            #set($macro.classExpression = "${macro.actualType.canonicalNameOrName}.class")
            #if($macro.hasParamRequiringMatcher)
                #set($param.initExpression = "eq($macro.classExpression)")
            #else
                #set($param.initExpression = "$macro.classExpression")
            #end
        ## Handle generic type arguments; e.g. T, not List<T>.
        #elseif($param.type.generic)
            #if(!$macro.hasParamRequiringMatcher)
                ## Use values for all arguments.
                #set($param.initExpression = $macro.actualType.initExpression)
            #elseif($macro.actualType.primitive || $macro.actualType.overridesEquals)
                ## We need to use matchers. Use eq(...) if possible.
                #set($param.initExpression = "eq($macro.actualType.initExpression)")
            #else
                ## We need to use matchers. A custom matcher is needed to validate the argument. Use any(...) for now.
                #set($param.initExpression = "any(${macro.actualType.canonicalNameOrName}.class)")
            #end
        ## Handle the case where the formal parameter is an interface or abstract class that does not override
        ## Object.equals, but the actual type does.
        #elseif(!$param.type.overridesEquals && $macro.actualType.overridesEquals)
            #if(!$macro.hasParamRequiringMatcher)
                ## Use values for all arguments.
                #set($param.initExpression = $macro.actualType.initExpression)
            #else
                ## We need to use matchers. Use eq(...).
                #set($param.initExpression = "eq($macro.actualType.initExpression)")
            #end
        ## Handle all remaining cases where we need to use matchers.
        #elseif($macro.hasParamRequiringMatcher)
            #if($param.type.primitive || $param.type.overridesEquals || $macro.actualType.overridesEquals)
                ## We need to use matchers. Use eq(...) if possible.
                #set($param.initExpression = "eq($param.initExpression)")
            #else
                ## We need to use matchers. A custom matcher is needed to validate the argument. Use any(...) for now.
                #set($param.initExpression = "any(${param.type.canonicalNameOrName}.class)")
            #end
        #end
    #end
    #end
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## initializeDependencyInteractionMethodReturnType($di)
## Initializes the initExpression, testClassLocalFieldName and other fields in the $di.method.returnType.
## Param: $di the dependency interaction whose return type will be initialized.
##----------------------------------------------------------------------------------------------------------------------
#macro(initializeDependencyInteractionMethodReturnType $di)
    #if($di.method.returnType.dtoBean || !$di.method.returnType.initExpressionBeans.empty)
        #set($di.method.returnType.shouldStoreInReference = true)
    #end
    #if($ListenableFutureNames.contains($di.method.returnType.canonicalName))
        #set($di.method.returnType.shouldStoreInReference = true)
    #end
    #if($di.method.returnType.closeable)
        #set($di.method.returnType.shouldStoreInReference = true)
        #if($di.method.returnType.initExpression.equals('null'))
            #set($di.method.returnType.shouldBeMocked = true)
        #else
            #useInlineSpyForParam($di.method.returnType)
            #set($di.method.returnType.testClassLocalFieldName = "spy$StringUtils.capitalize($di.method.returnType.name)")
        #end
    #end
    #if($di.method.returnType.shouldBeMocked)
        #set($di.method.returnType.shouldStoreInReference = true)
        #useInlineMockForParam($di.method.returnType)
        #set($di.method.returnType.testClassLocalFieldName = "mock$StringUtils.capitalize($di.method.returnType.name)")
    #end
    #if($ClassUtils.removePackageQualifiers($di.method.returnType.initExpression).length() > 40)
        #set($di.method.returnType.shouldStoreInReference = true)
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## setTestClassNamesForParam($param)
## Sets the Variable.testClassMemberName and Variable.testClassLocalFieldName properties on the given $param
## based on the Quick Settings.
## Param: $param the Variable to update
##----------------------------------------------------------------------------------------------------------------------
#macro(setTestClassNamesForParam $param)
    #if($param.shouldBeMocked)
        #if(${StringUtils.isNotEmpty($mockDependencyMemberNamePrefix)})
            #set($param.testClassMemberName = "${mockDependencyMemberNamePrefix}${StringUtils.capitalize(${param.declaredNameWithoutPrefix})}")
        #elseif (${StringUtils.isNotEmpty($dependencyMemberNamePrefix)})
            #set($param.testClassMemberName = "${dependencyMemberNamePrefix}${StringUtils.capitalize(${param.declaredNameWithoutPrefix})}")
        #end
        #if(${StringUtils.isNotEmpty($mockParameterLocalFieldNamePrefix)})
            #set($param.testClassLocalFieldName = "${mockParameterLocalFieldNamePrefix}${StringUtils.capitalize(${param.declaredNameWithoutPrefix})}")
        #elseif (${StringUtils.isNotEmpty($parameterLocalFieldNamePrefix)})
            #set($param.testClassLocalFieldName = "${parameterLocalFieldNamePrefix}${StringUtils.capitalize(${param.declaredNameWithoutPrefix})}")
        #end
    #else
        #if(${StringUtils.isNotEmpty($dependencyMemberNamePrefix)})
            #set($param.testClassMemberName = "${dependencyMemberNamePrefix}${StringUtils.capitalize(${param.declaredNameWithoutPrefix})}")
        #end
        #if(${StringUtils.isNotEmpty($parameterLocalFieldNamePrefix)})
            #set($param.testClassLocalFieldName = "${parameterLocalFieldNamePrefix}${StringUtils.capitalize(${param.declaredNameWithoutPrefix})}")
        #end
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## useInlineMockForParam($param)
## Updates the given parameter to use an inline mock expression; e.g. mock(Foo.class) wherever the parameter is needed.
## Param: $param the Variable to update
##----------------------------------------------------------------------------------------------------------------------
#macro(useInlineMockForParam $param)
    #if($useStaticImportForInitMocks)
        #set($param.initExpression = "mock(${param.type.canonicalName}.class)")
        #if($param.type.isAny('java.lang.Iterable'))
            #set($param.type.emptyInitExpression = "mock(${param.type.canonicalName}.class)")
        #end
        #set($_ = $importLinesRequired.add("import static org.mockito.Mockito.mock;"))
    #else
        #set($param.initExpression = "Mockito.mock(${param.type.canonicalName}.class)")
        #if($param.type.isAny('java.lang.Iterable'))
            #set($param.type.emptyInitExpression = "mock(${param.type.canonicalName}.class)")
        #end
        #set($_ = $importLinesRequired.add("import org.mockito.Mockito;"))
    #end
    #set($param.shouldBeMocked = true)
#end

##----------------------------------------------------------------------------------------------------------------------
## useInlineSpyForParam($param)
## Updates the given parameter to use an inline mock expression; e.g. mock(Foo.class) wherever the parameter is needed.
## Param: $param the Variable to update
##----------------------------------------------------------------------------------------------------------------------
#macro(useInlineSpyForParam $param)
    #if($useStaticImportForInitMocks)
        #set($param.initExpression = "spy($param.initExpression)")
        #if($param.type.emptyInitExpression)
            #set($param.type.emptyInitExpression = "spy($param.type.emptyInitExpression)")
        #end
        #if($param.type.absentInitExpression && !$StringUtils.equals($param.type.absentInitExpression, 'null'))
            #set($param.type.absentInitExpression = "spy($param.type.absentInitExpression)")
        #end
        #if($param.type.emptyIoInitExpression)
            #set($param.type.emptyIoInitExpression = "spy($param.type.emptyIoInitExpression)")
        #end
        #if($param.type.brokenIoInitExpression)
            #set($param.type.brokenIoInitExpression = "spy($param.type.brokenIoInitExpression)")
        #end
        #set($_ = $importLinesRequired.add("import static org.mockito.Mockito.spy;"))
    #else
        #set($param.initExpression = "Mockito.spy($param.initExpression)")
        #if($param.type.emptyInitExpression)
            #set($param.type.emptyInitExpression = "Mockito.spy($param.type.emptyInitExpression)")
        #end
        #if($param.type.absentInitExpression && !$StringUtils.equals($param.type.absentInitExpression, 'null'))
            #set($param.type.absentInitExpression = "Mockito.spy($param.type.absentInitExpression)")
        #end
        #if($param.type.emptyIoInitExpression)
            #set($param.type.emptyIoInitExpression = "Mockito.spy($param.type.emptyIoInitExpression)")
        #end
        #if($param.type.brokenIoInitExpression)
            #set($param.type.brokenIoInitExpression = "Mockito.spy($param.type.brokenIoInitExpression)")
        #end
        #set($_ = $importLinesRequired.add("import org.mockito.Mockito;"))
    #end
    #set($param.shouldBeMocked = false)
    #set($param.shouldBeSpied = true)
#end

##----------------------------------------------------------------------------------------------------------------------
## askUserToConfirmSettingsIfNeeded()
## Shows a dialog asking the user to confirm which dependencies should be mocked if the template was invoked with
## $shouldAskToConfirmSettings = true. The variable: $shouldAskToConfirmSettings is true when the user invokes the
## "Generate Test - Confirm Mocks" action from the Squaretest menu.
##----------------------------------------------------------------------------------------------------------------------
#macro(askUserToConfirmSettingsIfNeeded)
    #if($shouldAskToConfirmSettings)
        ## Show the dialog to ask the user to confirm the provided settings.
        #set($userProvidedSettings =
            $UiUtils.askUserToConfirmSettings({
                'dependencies' : $dependencies,
                'memberFields' : $memberFields,
                'mockMemberFields' : $mockMemberFields,
                'nonMockMemberFields' : $nonMockMemberFields,
                'sourceClassMemberNeeded' : $sourceClassMemberNeeded,
                'shouldUseInjectMocks' : $shouldUseInjectMocks,
                'shouldSetPackageLocalFields' : $shouldSetPackageLocalFields,
                'mocksNeeded' : $mocksNeeded,
                'shouldCreateTestsForInstanceMethods' : $shouldCreateTestsForInstanceMethods,
                'mockMvcMemberName' : $mockMvcMemberName
        }))
        #set($dependencies = $userProvidedSettings.get('dependencies'))
        #set($memberFields = $userProvidedSettings.get('memberFields'))
        #set($mockMemberFields = $userProvidedSettings.get('mockMemberFields'))
        #set($nonMockMemberFields = $userProvidedSettings.get('nonMockMemberFields'))
        #set($sourceClassMemberNeeded = $userProvidedSettings.get('sourceClassMemberNeeded'))
        #set($shouldUseInjectMocks = $userProvidedSettings.get('shouldUseInjectMocks'))
        #set($shouldSetPackageLocalFields = $userProvidedSettings.get('shouldSetPackageLocalFields'))
        #set($mocksNeeded = $userProvidedSettings.get('mocksNeeded'))
        #set($shouldCreateTestsForInstanceMethods = $userProvidedSettings.get('shouldCreateTestsForInstanceMethods'))
        #set($mockMvcMemberName = $userProvidedSettings.get('mockMvcMemberName'))
    #end
#end

## Declare global variables set by initializeTemplateDataModel() to enable partial code completion in the Velocity
## editor bundled with the IntelliJ IDEA Ultimate Edition.
## Constants.
#* @vtlvariable name="ListenableFutureNames" type="java.util.Set<java.lang.String>" *#
#* @vtlvariable name="ListenableFutureToSettableFutureMap" type="java.util.Map<java.lang.String, java.util.List<java.lang.String>>" *#
#* @vtlvariable name="BooleanTypes" type="java.util.List<java.lang.String>" *#
#* @vtlvariable name="NumericTypes" type="java.util.List<java.lang.String>" *#
#* @vtlvariable name="MultipartInterfaceTypes" type="java.util.List<java.lang.String>" *#
#* @vtlvariable name="IgnoredControllerTypes" type="java.util.List<java.lang.String>" *#
#* @vtlvariable name="RequestMappingAnnotations" type="java.util.List<java.lang.String>" *#
#* @vtlvariable name="ControllerMethodAnnotations" type="java.util.List<java.lang.String>" *#
#* @vtlvariable name="SecurityAnnotations" type="java.util.List<java.lang.String>" *#
#* @vtlvariable name="ControllerParameterAnnotations" type="java.util.List<java.lang.String>" *#

## General data types.
#* @vtlvariable name="dependencies" type="com.squaretest.template.api.Api.FluentList<com.squaretest.template.api.Api.Variable>" *#
#* @vtlvariable name="memberFields" type="com.squaretest.template.api.Api.FluentList<com.squaretest.template.api.Api.Variable>" *#
#* @vtlvariable name="mockMemberFields" type="com.squaretest.template.api.Api.FluentList<com.squaretest.template.api.Api.Variable>" *#
#* @vtlvariable name="nonMockMemberFields" type="com.squaretest.template.api.Api.FluentList<com.squaretest.template.api.Api.Variable>" *#
#* @vtlvariable name="sourceClassMemberNeeded" type="boolean" *#
#* @vtlvariable name="shouldUseInjectMocks" type="boolean" *#
#* @vtlvariable name="shouldSetPackageLocalFields" type="boolean" *#
#* @vtlvariable name="mocksNeeded" type="boolean" *#
#* @vtlvariable name="shouldUseSpring" type="boolean" *#
#* @vtlvariable name="shouldCreateTestsForInstanceMethods" type="boolean" *#
#* @vtlvariable name="initMocksMethodName" type="java.lang.String" *#
#* @vtlvariable name="hasOpenMocksMethod" type="boolean" *#

## Spring data types.
#* @vtlvariable name="springController" type="boolean" *#
#* @vtlvariable name="restController" type="boolean" *#
#* @vtlvariable name="hasClassSecurityAnnotations" type="boolean" *#
#* @vtlvariable name="controllerMethods" type="com.squaretest.template.api.Api.FluentList<com.squaretest.template.api.Api.Method>" *#
#* @vtlvariable name="modelAttributeProviderMethods" type="com.squaretest.template.api.Api.FluentList<com.squaretest.template.api.Api.Method>" *#
#* @vtlvariable name="modelAttributeProviderMethodDIs" type="com.squaretest.template.api.Api.FluentList<com.squaretest.template.api.Api.DependencyInteraction>" *#
#* @vtlvariable name="allModelAttributeProviderMethods" type="com.squaretest.template.api.Api.FluentList<com.squaretest.template.api.Api.Method>" *#
#* @vtlvariable name="basePath" type="java.lang.String" *#
#* @vtlvariable name="mockMvcMemberName" type="java.lang.String" *#

## Variables defined based on whether the $shouldUseMockitoBdd setting is enabled.
#* @vtlvariable name="doAnswer" type="java.lang.String" *#
#* @vtlvariable name="doReturn" type="java.lang.String" *#
#* @vtlvariable name="thenReturn" type="java.lang.String" *#
#* @vtlvariable name="when" type="java.lang.String" *#
#* @vtlvariable name="doThrow" type="java.lang.String" *#
#* @vtlvariable name="thenThrow" type="java.lang.String" *#

## Parameter names used in various macros.
#* @vtlvariable name="testInfo" type="com.squaretest.template.api.Api.TestInfo" *#
#* @vtlvariable name="exceptionToThrow" type="com.squaretest.template.api.Api.Exception" *#
#* @vtlvariable name="dependency" type="com.squaretest.template.api.Api.Variable" *#
#* @vtlvariable name="methods" type="com.squaretest.template.api.Api.FluentList<com.squaretest.template.api.Api.Method>" *#
#* @vtlvariable name="method" type="com.squaretest.template.api.Api.Method" *#
#* @vtlvariable name="param" type="com.squaretest.template.api.Api.Variable" *#
#* @vtlvariable name="typeOrVariable" type="com.squaretest.template.api.Api.Variable" *#
#* @vtlvariable name="type" type="com.squaretest.template.api.Api.Type" *#
#* @vtlvariable name="field" type="com.squaretest.template.api.Api.Variable" *#
#* @vtlvariable name="di" type="com.squaretest.template.api.Api.DependencyInteraction" *#
#* @vtlvariable name="testCaseSuffix" type="java.lang.String" *#
#* @vtlvariable name="beanSourceClass" type="com.squaretest.template.api.Api.SourceClass" *#
#* @vtlvariable name="shouldUseEmptyIo" type="boolean" *#
#* @vtlvariable name="shouldUseBrokenIo" type="boolean" *#
#* @vtlvariable name="recursiveCounter" type="int" *#
#* @vtlvariable name="numberOfSettersCalled" type="org.apache.commons.lang3.mutable.MutableInt" *#
#* @vtlvariable name="canonicalNamesInCallStack" type="java.util.Map<java.lang.String, java.lang.Boolean>" *#