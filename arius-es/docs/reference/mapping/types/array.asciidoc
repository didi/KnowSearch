[[array]]
=== Arrays

In Elasticsearch, there is no dedicated `array` datatype.  Any field can contain
zero or more values by default, however, all values in the array must be of the
same datatype. For instance:

* an array of strings: [ `"one"`, `"two"` ]
* an array of integers: [ `1`, `2` ]
* an array of arrays: [ `1`, [ `2`, `3` ]] which is the equivalent of [ `1`, `2`, `3` ]
* an array of objects: [ `{ "name": "Mary", "age": 12 }`, `{ "name": "John", "age": 10 }`]

.Arrays of objects
[NOTE]
====================================================

Arrays of objects do not work as you would expect: you cannot query each
object independently of the other objects in the array.  If you need to be
able to do this then you should use the <<nested,`nested`>> datatype instead
of the <<object,`object`>> datatype.

This is explained in more detail in <<nested>>.
====================================================


When adding a field dynamically, the first value in the array determines the
field `type`.  All subsequent values must be of the same datatype or it must
at least be possible to <<coerce,coerce>> subsequent values to the same
datatype.

Arrays with a mixture of datatypes are _not_ supported: [ `10`, `"some string"` ]

An array may contain `null` values, which are either replaced by the
configured <<null-value,`null_value`>> or skipped entirely.  An empty array
`[]` is treated as a missing field -- a field with no values.

Nothing needs to be pre-configured in order to use arrays in documents, they
are supported out of the box:


[source,console]
--------------------------------------------------
PUT my_index/_doc/1
{
  "message": "some arrays in this document...",
  "tags":  [ "elasticsearch", "wow" ], <1>
  "lists": [ <2>
    {
      "name": "prog_list",
      "description": "programming list"
    },
    {
      "name": "cool_list",
      "description": "cool stuff list"
    }
  ]
}

PUT my_index/_doc/2 <3>
{
  "message": "no arrays in this document...",
  "tags":  "elasticsearch",
  "lists": {
    "name": "prog_list",
    "description": "programming list"
  }
}

GET my_index/_search
{
  "query": {
    "match": {
      "tags": "elasticsearch" <4>
    }
  }
}
--------------------------------------------------

<1> The `tags` field is dynamically added as a `string` field.
<2> The `lists` field is dynamically added as an `object` field.
<3> The second document contains no arrays, but can be indexed into the same fields.
<4> The query looks for `elasticsearch` in the `tags` field, and matches both documents.

[[multi-value-fields-inverted-index]]
.Multi-value fields and the inverted index
****************************************************

The fact that all field types support multi-value fields out of the box is a
consequence of the origins of Lucene.  Lucene was designed to be a full text
search engine.  In order to be able to search for individual words within a
big block of text, Lucene tokenizes the text into individual terms, and
adds each term to the inverted index separately.

This means that even a simple text field must be able to support multiple
values by default.  When other datatypes were added, such as numbers and
dates, they used the same data structure as strings, and so got multi-values
for free.

****************************************************

